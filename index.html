<!DOCTYPE html>

<html lang="pt-PT">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>LuxTIPS</title>
<style>
/* ================= THEME SYSTEM ================= */
:root{
  --bg:#070b16;
  --panel:rgba(20,28,56,0.75);
  --ink:#e5e7eb;
  --brand:#22d3ee;
  --green:#10b981;
  --yellow:#f59e0b;
  --red:#ef4444;
  --muted:#9ca3af;
  --glow:0 0 20px rgba(34,211,238,.25);
}

[data-theme="dark"]{
  --bg:#070b16;
  --panel:rgba(20,28,56,0.75);
  --ink:#e5e7eb;
  --brand:#22d3ee;
  --glow:0 0 20px rgba(34,211,238,.25);
}

[data-theme="neon"]{
  --bg:#050008;
  --panel:rgba(24,0,60,0.75);
  --ink:#f8fafc;
  --brand:#f0abfc;
  --glow:0 0 24px rgba(236,72,153,.45);
}

*{box-sizing:border-box}
body{
  margin:0;
  background:
    radial-gradient(1200px 600px at 20% -10%, rgba(34,211,238,.15), transparent 40%),
    radial-gradient(1200px 600px at 80% 110%, rgba(99,102,241,.18), transparent 40%),
    linear-gradient(180deg,#050713,#070b16 40%, #070b16);
  color:var(--ink);
  font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;
  min-height:100vh;
}

[data-theme="neon"] body{
  background:
    radial-gradient(1200px 600px at 20% -10%, rgba(236,72,153,.25), transparent 40%),
    radial-gradient(1200px 600px at 80% 110%, rgba(124,58,237,.25), transparent 40%),
    linear-gradient(180deg,#020003,#050008 40%, #050008);
}

header{
  position:sticky; top:0; z-index:50;
  backdrop-filter: blur(12px);
  background: linear-gradient(180deg, rgba(15,23,42,.85), rgba(7,11,22,.85));
  border-bottom:1px solid rgba(255,255,255,.08);
  padding:18px 28px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
}

[data-theme="neon"] header{
  background: linear-gradient(180deg, rgba(40,0,80,.85), rgba(5,0,20,.85));
}

h1{
  margin:0;
  font-size:24px;
  letter-spacing:.5px;
  background:linear-gradient(90deg,var(--brand),#60a5fa,var(--brand));
  background-size:200% 100%;
  -webkit-background-clip:text;
  background-clip:text;
  color:transparent;
  animation:shift 6s linear infinite;
}

h1.brand{
  display:flex;
  align-items:center;
  gap:10px;
}
.mini-logo{
  width:22px;
  height:22px;
  object-fit:contain;
  filter: drop-shadow(0 10px 20px rgba(0,0,0,.45));
}
.sub{font-size:13px;color:var(--muted)}
@keyframes shift{0%{background-position:0%}100%{background-position:200%}}

main{
  width:100%;
  max-width:1320px;
  margin:0 auto;
  padding:16px 10px 40px;
  display:grid;
  grid-template-columns:1fr;
  gap:16px;
}

.card{
  background: linear-gradient(180deg, rgba(24,34,70,.85), rgba(12,18,38,.85));
  border:1px solid rgba(255,255,255,.08);
  border-radius:18px;
  padding:18px 20px;
  box-shadow:
    0 0 0 1px rgba(255,255,255,.02) inset,
    0 20px 40px rgba(0,0,0,.45),
    var(--glow);
  position:relative;
  overflow:hidden;
}

[data-theme="neon"] .card{
  background: linear-gradient(180deg, rgba(64,0,128,.85), rgba(20,0,60,.85));
}

.row{display:flex;gap:14px;flex-wrap:wrap;align-items:flex-end}
label{font-size:12px;color:#c7d2fe;letter-spacing:.2px}
input,select,button{
  background:rgba(10,16,36,.9);
  border:1px solid rgba(255,255,255,.12);
  color:#fff;
  border-radius:12px;
  padding:9px 12px;
}
[data-theme="neon"] input,
[data-theme="neon"] select{
  background:rgba(8,0,24,.9);
}

input[type=file]{padding:7px 10px}

button{
  cursor:pointer;
  background: linear-gradient(135deg,#06b6d4,#3b82f6);
  border:none;
  font-weight:600;
  box-shadow:0 10px 25px rgba(59,130,246,.35), 0 0 0 1px rgba(255,255,255,.15) inset;
}
button:hover{filter:brightness(1.06)}
[data-theme="neon"] button{
  background: linear-gradient(135deg,#ec4899,#8b5cf6);
  box-shadow:0 10px 30px rgba(236,72,153,.5);
}

.btn-s{font-size:12px;padding:7px 12px;background:linear-gradient(135deg,#334155,#1e293b)}
[data-theme="neon"] .btn-s{
  background:linear-gradient(135deg,#581c87,#312e81);
}

table{width:100%;border-collapse:separate;border-spacing:0 6px;font-size:13px}
th,td{padding:9px 10px;text-align:left}
th{color:#7dd3fc;font-weight:600;border-bottom:1px solid rgba(255,255,255,.15)}
[data-theme="neon"] th{color:#f0abfc}

tbody tr{background:rgba(12,18,38,.9);box-shadow:0 8px 18px rgba(0,0,0,.35)}
[data-theme="neon"] tbody tr{background:rgba(30,0,70,.9)}

.badge{display:inline-block;padding:2px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.25);margin-right:6px;font-size:11px}
.badge.good{border-color:var(--green);color:var(--green)}
.badge.warn{border-color:var(--yellow);color:#facc15}
.badge.bad{border-color:var(--red);color:#f87171}

.mot-chip{
  display:inline-flex;
  align-items:center;
  gap:4px;
  margin-left:6px;
  padding:2px 6px;
  border-radius:999px;
  border:1px solid rgba(248,250,252,0.18);
  font-size:10px;
  opacity:0.9;
}
.mot-hot{ color:#f97316; }
.mot-danger{ color:#f97316; border-color:rgba(248,113,113,.7); }


.conf{height:8px;background:#0b122a;border-radius:999px;overflow:hidden;width:80px;margin:4px auto 0 auto}
.fill{height:100%;background:linear-gradient(90deg,#ef4444,#f59e0b,#10b981);width:0%}

.explain{white-space:pre-wrap;font-size:12px;color:#e5e7eb;background:rgba(7,11,22,.85);border:1px dashed rgba(125,211,252,.35);border-radius:10px;padding:10px}

.mini-grid{display:flex;flex-wrap:wrap;gap:12px;margin-top:8px}
.mini-table{flex:1 1 240px;background:rgba(7,11,22,.8);border-radius:10px;padding:8px;border:1px dashed rgba(148,163,184,.5)}
.mini-title{font-size:11px;font-weight:600;color:#a5b4fc;margin-bottom:4px}
.mini-table table{width:100%;border-collapse:collapse;font-size:11px}
.mini-table th,.mini-table td{padding:2px 4px;text-align:left;white-space:nowrap}
.mini-table th{font-weight:600;color:#e5e7eb;border-bottom:1px solid rgba(55,65,81,.7)}
.mini-row{cursor:pointer}
.mini-row:hover{background:rgba(31,41,55,.6)}
.mini-res{font-weight:600}
.res-V{color:#22c55e;}
.res-E{color:#eab308;}
.res-D{color:#f97373;}
.mini-stats-panel{margin-top:10px;padding:10px;border-radius:10px;border:1px dashed rgba(148,163,184,.5);background:rgba(7,11,22,.85);font-size:11px}
.standings-block{
  margin-top:10px;
  padding:8px 10px;
  border-radius:10px;
  border:1px dashed rgba(148,163,184,.5);
  background:rgba(7,11,22,.9);
  font-size:11px;
}
.standings-title{
  font-weight:600;
  color:#e5e7eb;
  margin-bottom:2px;
}
.standings-sub{
  font-size:10px;
  color:#9ca3af;
  margin-bottom:6px;
}
.standings-table{
  width:100%;
  table-layout:fixed;
  border-collapse:collapse;
  font-size:11px;
}
.standings-table th,
.standings-table td{
  padding:3px 4px;
  text-align:center;
  white-space:nowrap;
}
.standings-table th{
  color:#cbd5f5;
  border-bottom:1px solid rgba(55,65,81,.9);
  font-weight:600;
}
.standings-table td:first-child{
  text-align:right;
}
.standings-table td:nth-child(2){
  text-align:left;
}
.standings-highlight{
  background:rgba(37,99,235,.25);
}
.standings-form{
  display:flex;
  gap:2px;
  justify-content:center;
  flex-wrap:nowrap;
}
.form-badge{
  width:16px;
  height:16px;
  border-radius:3px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:9px;
  font-weight:600;
  color:#0b1120;
}
.form-W{background:#22c55e;}
.form-D{background:#eab308;}
.form-L{background:#ef4444;}

.mini-stats-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  margin-bottom:4px;
}

.mini-stats-match{
  font-size:11px;
  color:#cbd5f5;
  margin-bottom:4px;
}

.btn-close-stats{
  padding:3px 8px;
  font-size:10px;
}

.mini-stat-row{display:flex;align-items:center;gap:8px;margin-bottom:6px}
.mini-stat-label{flex:0 0 150px;color:#cbd5f5}
.mini-stat-bars{flex:1;display:flex;height:8px;border-radius:999px;overflow:hidden;background:rgba(15,23,42,.9)}
.mini-stat-bar-home{background:rgba(34,197,94,.9)}
.mini-stat-bar-away{background:rgba(248,113,113,.9)}
.mini-stat-values{flex:0 0 70px;text-align:right;color:#e5e7eb}
[data-theme="neon"] .explain{
  background:rgba(20,0,60,.85);
  border-color:rgba(236,72,153,.5);
}

details{border:1px dashed rgba(125,211,252,.35);border-radius:12px;padding:10px;margin-top:10px}
details[open]{background:rgba(7,11,22,.6)}
[data-theme="neon"] details[open]{background:rgba(20,0,60,.6)}

.tiny{font-size:11px;color:#9ca3af}

/* THEME TOGGLE */
.theme-toggle{
  position:absolute; right:20px; top:18px;
  display:flex; gap:8px;
}
.theme-toggle button{
  padding:6px 10px;
  font-size:11px;
}

/* LOADING OVERLAY */
.loading-overlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:radial-gradient(circle at top, rgba(15,23,42,.85), rgba(15,23,42,.96));
  backdrop-filter:blur(18px);
  z-index:80;
}
.loading-card{
  min-width:260px;
  padding:18px 20px 16px;
  border-radius:18px;
  background:linear-gradient(145deg, rgba(15,23,42,.96), rgba(15,23,42,.9));
  box-shadow:0 24px 60px rgba(0,0,0,.75), 0 0 0 1px rgba(148,163,184,.35);
  text-align:center;
}
.loading-spinner{
  width:32px;height:32px;
  border-radius:999px;
  border:3px solid rgba(148,163,184,.35);
  border-top-color:var(--brand);
  margin:0 auto 10px;
  animation:spin 0.9s linear infinite;
}
.loading-text{
  font-size:13px;
  margin-bottom:8px;
  color:var(--muted);
}
.loading-bar{
  width:100%;
  height:8px;
  border-radius:999px;
  background:rgba(15,23,42,1);
  overflow:hidden;
  margin-bottom:4px;
}
.loading-bar-fill{
  height:100%;
  width:0%;
  background:linear-gradient(90deg,#22d3ee,#38bdf8,#a855f7);
  transition:width .18s ease-out;
}
.loading-percent{
  font-size:11px;
  color:#9ca3af;
}
@keyframes spin{
  to{transform:rotate(360deg)}
}


@media (max-width: 768px){
  body{
    font-size:14px;
  }
  header{
    padding:14px 16px;
  }
  header h1{
    font-size:20px;
  }
  .card{
    padding:14px 12px;
  }
  .row{
    flex-direction:column;
    align-items:stretch;
  }
  input,
  select,
  button{
    width:100%;
    max-width:100%;
  }
  .results-tabs{
    top:8px;
    font-size:11px;
    padding:3px 4px;
    gap:4px;
    max-width:100%;
    overflow-x:auto;
  }
  .tab-btn{
    min-width:80px;
    padding:4px 8px;
  }
  #picks, #best1x2, #summary, #calib{
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
  }
  table{
    font-size:12px;
  }
}
}

<style>
    /* … aqui está todo o teu CSS atual … */


    /* === TORNAR O "VER EXPLICAÇÃO" CLICÁVEL EM TODA A LARGURA === */

    details summary{
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:8px 12px;
      margin:-4px -6px;
      border-radius:10px;
      width:100%;
    }

    details summary::-webkit-details-marker{
      display:none;
    }

    details summary::marker{
      content:'';
    }

    details summary::after{
      content:'▼';
      font-size:10px;
      opacity:0.7;
      margin-left:8px;
    }

    details[open] summary::after{
      content:'▲';
    }

    details summary:hover{
      background:rgba(15,23,42,0.75);
    }

    details[open] summary{
      background:rgba(15,23,42,0.9);
    }


/* === Tabs de resultados (Picks / 1X2 / Múltipla / Diag. calibração) === */
.results-tabs{
  position:fixed;
  left:50%;
  transform:translateX(-50%);
  /* fica logo abaixo do header */
  top:76px;
  /* acima do header para nunca ficar escondido */
  z-index:120;
  display:flex;
  flex-wrap:nowrap;
  gap:6px;
  font-size:13px;
  padding:4px 6px;
  background:linear-gradient(180deg, rgba(15,23,42,0.98), rgba(15,23,42,0.9));
  border-radius:999px;
  box-shadow:0 8px 20px rgba(0,0,0,.6);
}



.tab-btn{
  flex:1 1 auto;
  min-width:90px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(148,163,184,.6);
  background:rgba(15,23,42,.7);
  color:var(--muted);
  font-weight:500;
  cursor:pointer;
  transition:background .18s ease, color .18s ease, border-color .18s ease, transform .08s ease;
}

.tab-btn:hover{
  background:rgba(15,23,42,.9);
  transform:translateY(-1px);
}

.tab-btn.tab-active{
  background:rgba(34,211,238,.15);
  border-color:var(--brand);
  color:#e5e7eb;
  font-weight:600;
}

/* === Estilo da Múltipla moderna === */

.parlay-header{
  display:flex;
  flex-direction:column;
  gap:4px;
  margin-bottom:10px;
}

.parlay-pill{
  display:inline-flex;
  flex-wrap:wrap;
  align-items:center;
  gap:6px;
  padding:3px 9px;
  border-radius:999px;
  background:rgba(15,23,42,.9);
  border:1px solid rgba(148,163,184,.6);
  font-size:11px;
  color:#e5e7eb;
}

.parlay-odd-main{
  font-size:14px;
  font-weight:600;
  color:#facc15;
}

.parlay-note{
  font-size:11px;
  color:#9ca3af;
}

.parlay-items{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
  gap:10px;
  margin-top:8px;
}

.parlay-item{
  padding:10px 12px;
  border-radius:12px;
  background:rgba(7,11,22,.9);
  border:1px solid rgba(148,163,184,.35);
  font-size:12px;
  display:flex;
  flex-direction:column;
  gap:4px;
}

.parlay-dt{font-size:12px; margin:6px 0 2px; display:inline-block; background:#e5e7eb; color:#111827; padding:4px 10px; border-radius:999px;}
.parlay-line{
  font-size:11px;
  color:#9ca3af;
}

.parlay-match{
  font-weight:600;
}

.parlay-market{
  font-size:12px;
  color:#e5e7eb;
}

.parlay-meta{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-top:2px;
  font-size:11px;
}

.parlay-odd-pill{
  padding:2px 8px;
  border-radius:999px;
  background:rgba(15,23,42,1);
  border:1px solid rgba(250,204,21,.6);
  color:#facc15;
}

.parlay-conf{
  padding:2px 8px;
  border-radius:999px;
  border:1px solid rgba(148,163,184,.6);
  color:#e5e7eb;
}

/* Mobile: tabs mais pequenos e com scroll horizontal se necessário */
@media (max-width: 768px){
  .results-tabs{
    font-size:11px;
    padding:4px 0;
    gap:4px;
    /* também abaixo do header em mobile */
    top:76px;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
  }
  .results-tabs::-webkit-scrollbar{
    display:none;
  }
  .tab-btn{
    flex:0 0 auto;
    min-width:80px;
    padding:4px 8px;
  }
}



/* Botão desactivado (usado enquanto está a carregar dados automaticamente) */
button[disabled],
button.btn-disabled{
  opacity:0.6;
  cursor:not-allowed;
  box-shadow:none;
}


/* ===== Mobile-first polish (no horizontal scroll) ===== */
html, body{max-width:100%; overflow-x:hidden;}
/* Make any legacy tables wrap instead of forcing horizontal scroll */
table{width:100%; table-layout:fixed;}
th, td{word-break:break-word; overflow-wrap:anywhere;}
/* Mini tables: allow wrapping */
.mini-table th,.mini-table td{white-space:normal !important;}
/* Disable horizontal scroll containers */
#picks, #best1x2, #summary, #calib{overflow-x:visible !important;}
#calib{display:none !important;}
/* Hide tabs + manual gerar (auto-run) */
/* Floating "Topo" button */
.match-card{
  width:100%;
  border:1px solid rgba(148,163,184,.25);
  background:rgba(7,11,22,.85);
  border-radius:14px;
  padding:10px 12px;
  margin:10px 0;
}
.match-head{
  display:flex;
  gap:10px;
  align-items:flex-start;
  justify-content:space-between;
  cursor:pointer;
}
.match-left{min-width:0; flex:1;}
.match-meta{display:flex; gap:8px; flex-wrap:wrap; font-size:11px; color:#a5b4fc; margin-bottom:4px;}
.match-teams{font-size:14px; font-weight:800; line-height:1.2; color:#e5e7eb;}
.match-market{margin-top:6px; font-size:12px; color:#cbd5e1;}
.match-right{display:flex; flex-direction:column; align-items:flex-end; gap:6px; flex:0 0 auto;}

.match-kpis{
  display:grid;
  gap:6px;
  grid-template-columns: repeat(4, 74px);
  justify-content:end;
  align-items:stretch;
}
@media (max-width: 520px){
  .match-kpis{ grid-template-columns: repeat(2, 86px); }
}
.kpi{
  font-size:11px;
  color:#e5e7eb;
  padding:6px 8px;
  border-radius:12px;
  background:rgba(2,6,23,.45);
  border:1px solid rgba(148,163,184,.18);
  text-align:center;
  line-height:1.15;
  font-variant-numeric: tabular-nums;
  -webkit-font-smoothing: antialiased;
}
.kpi span{
  display:block;
  color:#94a3b8;
  font-weight:800;
  margin:0 0 3px 0;
  letter-spacing:.01em;
}
.badge{font-size:11px; font-weight:800; padding:4px 8px; border-radius:999px; border:1px solid rgba(148,163,184,.25); background:rgba(2,6,23,.6);}
.badge b{font-weight:900;}
.match-body{display:none; margin-top:10px; border-top:1px dashed rgba(148,163,184,.25); padding-top:10px;}
.match-card.open .match-body{display:block;}
.explain{background:transparent; border:0; padding:0; font-size:12px;}
.close-inline{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  margin-bottom:10px;
  border:1px solid rgba(148,163,184,.25);
  background:rgba(2,6,23,.6);
  color:#e5e7eb;
  padding:8px 10px;
  border-radius:12px;
  font-weight:800;
  font-size:12px;
}
.close-inline:active{transform:translateY(1px);}


/* === Mobile refinements (Telegram) === */
:root{ --fabSafeBottom: 16px; }

.prob-strip{height:10px;border-radius:999px;background:rgba(148,163,184,.22);overflow:hidden;margin-top:10px}
.prob-strip .fill{height:100%;border-radius:999px}
.match-teams{word-break:break-word}
.match-market{word-break:break-word}
.kpi{min-width:0}
.kpi span{display:block;opacity:.75;font-size:12px;line-height:1.1}
.kpi{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

@media (max-width: 560px){
  body{padding:12px}
  .match-head{flex-direction:column; align-items:stretch; gap:10px}
  .match-left{width:100%}
  .match-right{width:100%}
  .match-meta{justify-content:center; text-align:center}
  .match-teams{font-size:18px; text-align:center; line-height:1.15}
  .match-market{text-align:center; margin-top:6px}
  .match-kpis{display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:8px; width:100%}
  .kpi{padding:8px 10px; text-align:center}
  .conf{display:none} /* substituído por prob-strip full width */
  .match-body{padding-top:44px} /* espaço para FAB close */
}

/* Standings: impedir sobreposição e cortar nomes (ellipsis) */
.tbl-standings{width:100%; border-collapse:separate; border-spacing:0; table-layout:fixed}
.tbl-standings th,.tbl-standings td{padding:6px 6px; vertical-align:middle; overflow:hidden; text-overflow:ellipsis;
  max-width:0; white-space:nowrap}
.tbl-standings th:nth-child(1), .tbl-standings td:nth-child(1){width:34px; text-align:right}
.tbl-standings th:nth-child(2), .tbl-standings td:nth-child(2){width:auto}
.tbl-standings th:nth-child(3), .tbl-standings td:nth-child(3){width:44px; text-align:right}
.tbl-standings th:nth-child(4), .tbl-standings td:nth-child(4){width:40px; text-align:right}
.tbl-standings th:last-child, .tbl-standings td:last-child{width:84px; text-align:left}

/* Floating close-all button */
.fab{position:fixed; right:10px; bottom:calc(var(--fabSafeBottom) + 56px); z-index:9999;
  padding:6px 10px; border-radius:999px; border:1px solid rgba(148,163,184,.35);
  background:rgba(2,6,23,.82); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  color:#e5e7eb; font-weight:800; font-size:12px; box-shadow:0 10px 26px rgba(0,0,0,.35); }
.fab:active{transform:translateY(1px)}
.fab-close{bottom:calc(var(--fabSafeBottom) + 108px);}
@media (max-width:560px){
  #goTop{bottom:calc(var(--fabSafeBottom) + 16px)}
  #closeAll{bottom:calc(var(--fabSafeBottom) + 64px)}
}


@media (max-width:560px){
  .standings-table{font-size:10px;}
  .standings-table th,.standings-table td{padding:2px 3px;}
  .form-badge{width:14px;height:14px;font-size:8px;}
}

/* ================= INTRO / SPLASH ================= */
#introOverlay{
  position:fixed; inset:0; z-index:99999;
  display:flex; align-items:center; justify-content:center;
  padding:24px;
  background:
    radial-gradient(1200px 600px at 50% 30%, rgba(59,130,246,.18), rgba(0,0,0,0) 60%),
    radial-gradient(900px 500px at 50% 70%, rgba(245,158,11,.14), rgba(0,0,0,0) 55%),
    rgba(3,7,18,.96);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  animation:introIn .55s ease-out both;
}
#introOverlay .intro-inner{
  width:min(420px, 92vw);
  text-align:center;
  transform: translateY(8px) scale(.98);
  animation:introPop .85s cubic-bezier(.2,.9,.2,1) .05s both;
}
#introOverlay .intro-logo{
  width:min(220px, 64vw);
  height:auto;
  display:block;
  margin:0 auto 12px auto;
  filter: drop-shadow(0 14px 28px rgba(0,0,0,.55));
}
#introOverlay .intro-title{
  font-weight:900;
  letter-spacing:.5px;
  font-size: clamp(22px, 5.4vw, 34px);
  line-height:1.05;
  margin-top:2px;
}
#introOverlay .intro-slogan{
  margin-top:8px;
  font-weight:600;
  opacity:.86;
  font-size: clamp(12px, 3.6vw, 15px);
}
#introOverlay.intro-out{
  animation:introOut .55s ease-in both;
}
@keyframes introIn{
  from{ opacity:0; }
  to{ opacity:1; }
}
@keyframes introPop{
  0%{ opacity:0; transform: translateY(10px) scale(.96); }
  100%{ opacity:1; transform: translateY(0) scale(1); }
}
@keyframes introOut{
  from{ opacity:1; transform: translateY(0); }
  to{ opacity:0; transform: translateY(-12px); }
}


/* Intro progress (logo + barra) */
#introOverlay .intro-progress{margin-top:14px}
#introOverlay .intro-progress-bar{
  width:min(360px, 86vw);
  height:10px;
  border-radius:999px;
  background:rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.14);
  overflow:hidden;
  margin:0 auto;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
}
#introOverlay .intro-progress-fill{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, rgba(34,211,238,1), rgba(96,165,250,1), rgba(168,85,247,1));
  transition:width .16s ease-out;
}
#introOverlay .intro-progress-meta{
  width:min(360px, 86vw);
  margin:10px auto 0;
  display:flex;
  justify-content:space-between;
  gap:10px;
  font-size:12px;
  color:rgba(226,232,240,.88);
}
#introOverlay .intro-progress-text{opacity:.92}
#introOverlay .intro-progress-pct{font-variant-numeric: tabular-nums; opacity:.85}

</style>
<style id="parlayOnlyOverrides">
  /* PARLAY-ONLY CLEAN */
  #resultsTabs,#picksWrap,#best1x2Wrap,#summary,#calib,#expAll,#exp1x2,#copyExcel,#fileCard{display:none !important;}
  #parlayWrap{display:block !important;}
  body{
    background: radial-gradient(1200px 700px at 15% -10%, rgba(34,211,238,.30), transparent 60%),
                radial-gradient(900px 520px at 80% 0%, rgba(168,85,247,.22), transparent 55%),
                radial-gradient(900px 520px at 50% 120%, rgba(250,204,21,.10), transparent 55%),
                #070b16 !important;
  }
  .topbar{padding-top:18px;}
  .brand{
    display:flex;align-items:center;justify-content:center;gap:10px;
    font-weight:800;letter-spacing:.2px;
  }
  .brand .logoDot{
    width:12px;height:12px;border-radius:999px;background:#22d3ee;
    box-shadow:0 0 18px rgba(34,211,238,.7);
  }
  /* --- PARLAY SLIP UI --- */
#parlay .errorBox{
  background:rgba(2,6,23,.75);
  color:#e5e7eb;
  padding:14px 14px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.10);
  box-shadow:0 18px 50px rgba(0,0,0,.55);
  text-align:center;
}

/* Premium glass ticket */
#parlay .slipCard{
  background:
    radial-gradient(1200px 700px at 10% 0%, rgba(34,211,238,.10), transparent 55%),
    radial-gradient(900px 520px at 85% 10%, rgba(168,85,247,.10), transparent 55%),
    linear-gradient(180deg, rgba(8,12,24,.82), rgba(4,7,16,.78));
  color:#e5e7eb;
  border-radius:24px;
  padding:18px 18px 16px;
  border:1px solid rgba(255,255,255,.10);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  box-shadow:
    0 26px 70px rgba(0,0,0,.62),
    0 0 0 1px rgba(255,255,255,.04) inset;
  overflow:hidden;
}

/* League header */
#parlay .slipLeague{
  font-size:11px;
  font-weight:900;
  letter-spacing:.22em;
  color:rgba(226,232,240,.62);
  text-transform:uppercase;
  margin-top:14px;
  padding-top:14px;
  border-top:1px solid rgba(255,255,255,.08);
  text-align:center;
}

#parlay .slipLeague:first-child{
  margin-top:0;
  padding-top:0;
  border-top:none;
}

/* Date chip under league */
#parlay .slipLeagueDT,
#parlay .slipLeagueSubDT{
  display:inline-flex;
  align-items:center;
  gap:8px;
  margin:8px auto 0;
  font-size:12px;
  font-weight:800;
  color:#cbd5e1;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
  padding:6px 12px;
  border-radius:999px;
}

/* Each match row becomes a compact glass card */
#parlay .slipRow{
  margin:10px 0 0;
  padding:14px 12px 12px;
  border-radius:18px;
  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  border:1px solid rgba(255,255,255,.10);
  box-shadow:0 14px 30px rgba(0,0,0,.35);
  position:relative;
  overflow:hidden;
}
#parlay .slipRow::before{
  content:"";
  position:absolute;
  inset:0;
  pointer-events:none;
  background:
    radial-gradient(420px 180px at 10% 10%, rgba(34,211,238,.14), transparent 65%),
    radial-gradient(420px 180px at 90% 90%, rgba(168,85,247,.12), transparent 65%);
  opacity:.9;
}
#parlay .slipRow > *{ position:relative; z-index:1; }

#parlay .slipTeams{
  font-size:16px;
  font-weight:900;
  line-height:1.15;
  color:#f8fafc;
  letter-spacing:.01em;
}
#parlay .slipTeams{display:flex;align-items:center;gap:10px;flex-wrap:wrap;}
#parlay .teamChunk{display:inline-flex;align-items:center;gap:10px;}
#parlay .teamLogo{
  width:20px;height:20px;object-fit:contain;border-radius:5px;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
  box-shadow:0 8px 22px rgba(0,0,0,.35);
}
.teamLogoFallback{
  display:inline-flex;align-items:center;justify-content:center;
  width:18px;height:18px;border-radius:6px;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
  font-size:10px;font-weight:900;color:#e5e7eb;letter-spacing:-0.02em;
}
#parlay .vs{opacity:.55;font-weight:900;margin:0 4px;color:#cbd5e1;}

/* Meta pills */
#parlay .slipMeta{margin-top:10px;text-align:center;}
#parlay .pillTime{
  display:inline-flex;
  align-items:center;
  gap:8px;
  background:rgba(255,255,255,.06);
  border:1px solid rgba(255,255,255,.10);
  border-radius:999px;
  padding:6px 12px;
  font-size:12px;
  font-weight:800;
  color:#e2e8f0;
}
#parlay .pillPick{
  margin-top:10px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  background:linear-gradient(135deg, rgba(34,211,238,.18), rgba(59,130,246,.14));
  border:1px solid rgba(34,211,238,.20);
  border-radius:999px;
  padding:9px 14px;
  font-size:13px;
  font-weight:900;
  color:#f8fafc;
  box-shadow:0 10px 25px rgba(0,0,0,.25);
}

/* Total odd bar */
#parlay .slipOdd{
  margin-top:14px;
  background:
    linear-gradient(135deg, rgba(250,204,21,.95), rgba(245,158,11,.92));
  color:#0b1220;
  font-size:24px;
  font-weight:1000;
  text-align:center;
  padding:14px 14px;
  border-radius:18px;
  box-shadow:0 20px 45px rgba(0,0,0,.45);
  letter-spacing:.02em;
}
#parlay .slipOdd::selection{background:rgba(17,24,39,.15);}

/* Note */
#parlay .slipNote{
  margin-top:12px;
  font-size:11px;
  color:rgba(203,213,225,.7);
  text-align:center;
}
/* ---- Mobile responsiveness (telefóvel) ---- */
@media (max-width: 820px){
  body{ padding: 10px !important; }
  .wrap{ padding: 10px !important; }
  .shell{ width: 100% !important; max-width: 100% !important; margin: 0 auto !important; }
  .card{ border-radius: 18px !important; }
  .header{ padding: 14px 14px 10px !important; }
  .brand{ font-size: 20px !important; }
  .sub{ font-size: 12px !important; }

  /* Cards / list spacing */
  .list{ padding: 12px !important; }
  .leagueRow{ padding: 10px 10px 8px !important; }
  .leagueName{ font-size: 12px !important; letter-spacing: 0.12em !important; }
  .leagueMeta{ margin-top: 6px !important; }

  .matchRow{ padding: 10px 10px !important; }
  .teamLine{ gap: 8px !important; font-size: 15px !important; }
  .teamLogo{ width: 18px !important; height: 18px !important; margin-right: 6px !important; }
  .vs{ margin: 0 6px !important; }

  .pickPill{ font-size: 12px !important; padding: 7px 10px !important; border-radius: 999px !important; }

  /* Date/time chips */
  .slipLeagueSubDT{ font-size: 12px !important; padding: 4px 10px !important; }

  /* Odd bar */
  .oddBar{ padding: 14px 14px !important; }
  .oddBar .oddVal{ font-size: 22px !important; }
}

@media (max-width: 420px){
  body{ padding: 8px !important; }
  .brand{ font-size: 18px !important; }
  .teamLine{ font-size: 14px !important; }
  .teamLogo{ width: 17px !important; height: 17px !important; }
  .oddBar .oddVal{ font-size: 20px !important; }
  .pickPill{ font-size: 11.5px !important; }
  .footerNote{ font-size: 10px !important; padding: 8px 10px !important; }
}



/* ---- Mobile polish v6 ---- */
@media (max-width: 520px){
  /* Header/hero more compact */
  .header{ padding: 10px 12px 8px !important; }
  .hero{ padding: 14px 12px 10px !important; }
  .heroTitle{ font-size: 20px !important; line-height: 1.15 !important; }
  .heroSub{ font-size: 12px !important; opacity: .82 !important; }

  /* Card and list tighter */
  .card{ border-radius: 18px !important; }
  .list{ padding: 10px !important; }
  .matchRow{ padding: 10px 10px !important; }
  .leagueRow{ padding: 10px 10px 6px !important; }

  /* Date chip smaller and closer */
  .slipLeagueSubDT{ font-size: 11px !important; padding: 4px 10px !important; margin-top: 6px !important; }

  /* Teams row: keep single-line names when possible; ellipsis if needed */
  .teamLine{ display:flex !important; align-items:center !important; justify-content:center !important; flex-wrap: nowrap !important; gap: 8px !important; }
  .team{ display:flex !important; align-items:center !important; min-width: 0 !important; }
  .teamName{ display:inline-block !important; max-width: 140px !important; white-space: nowrap !important; overflow: hidden !important; text-overflow: ellipsis !important; }
  .vs{ opacity:.55 !important; margin: 0 6px !important; }

  /* Logos a bit smaller */
  .teamLogo{ width: 15px !important; height: 15px !important; margin-right: 6px !important; }

  /* Pick pill: avoid taking too much vertical space */
  .pickPill{ font-size: 12px !important; padding: 7px 12px !important; max-width: 100% !important; }
  .pickPill{ white-space: nowrap !important; overflow: hidden !important; text-overflow: ellipsis !important; }

  /* Odd bar compact */
  .oddBar{ padding: 12px 12px !important; border-radius: 14px !important; }
  .oddBar .oddVal{ font-size: 21px !important; }
}

@media (max-width: 380px){
  .teamName{ max-width: 118px !important; }
  .heroTitle{ font-size: 19px !important; }
  .pickPill{ font-size: 11.5px !important; }
}



/* ---- Mobile fix v8 (parlay layout) ---- */
@media (max-width: 520px){
  main{ padding: 10px 8px 28px !important; }

  /* Parlay: center and prevent team names stacking */
  #parlay .slipRow{ padding: 12px 6px !important; }
  #parlay .slipTeams{
    display:flex !important;
    align-items:center !important;
    justify-content:center !important;
    gap:10px !important;
    flex-wrap:nowrap !important; /* critical */
    text-align:center !important;
  }
  #parlay .teamChunk{ display:inline-flex !important; align-items:center !important; gap:8px !important; min-width:0 !important; }
  #parlay .teamName{
    display:inline-block !important;
    max-width: 128px !important;
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    vertical-align: bottom !important;
  }
  #parlay .vs{ flex:0 0 auto !important; margin: 0 4px !important; }

  /* Smaller pills and chips to reduce vertical height */
  #parlay .pillTime{ font-size: 11px !important; padding: 4px 10px !important; }
  #parlay .pillPick{ font-size: 12px !important; padding: 8px 12px !important; max-width: 100% !important;
    white-space: nowrap !important; overflow:hidden !important; text-overflow: ellipsis !important; }

  /* Odd bar */
  #parlay .slipOdd{ font-size: 22px !important; padding: 14px 14px !important; border-radius: 14px !important; }
}
@media (max-width: 380px){
  #parlay .teamName{ max-width: 112px !important; }
}



/* ---- Mobile layout v9: 2-col teams + centered league/date/pick ---- */
@media (max-width: 520px){
  #parlay .slipCard{ margin: 0 auto !important; }
  #parlay .slipLeague,
  #parlay .slipLeagueDT,
  #parlay .slipLeagueSubDT{
    text-align: center !important;
    width: 100% !important;
    margin-left: auto !important;
    margin-right: auto !important;
  }
  #parlay .pillPick{
    display: inline-block !important;
    margin: 10px auto 0 !important;
    text-align: center !important;
    max-width: 92% !important;
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
  }
  #parlay .slipRow{
    text-align: center !important;
    align-items: center !important;
  }
  /* Teams: 2 columns + vs center */
  #parlay .slipTeams{
    display: grid !important;
    grid-template-columns: 1fr auto 1fr !important;
    align-items: center !important;
    justify-items: center !important;
    gap: 10px !important;
    flex-wrap: nowrap !important; /* override desktop */
    width: 100% !important;
    margin-top: 6px !important;
  }
  #parlay .slipTeams .teamChunk{
    width: 100% !important;
    min-width: 0 !important;
    gap: 8px !important;
  }
  #parlay .slipTeams .teamChunk:first-child{ justify-content: flex-end !important; }
  #parlay .slipTeams .teamChunk:last-child{ justify-content: flex-start !important; }
  #parlay .vs{ justify-self: center !important; margin: 0 !important; }

  #parlay .teamName{
    display: inline-block !important;
    max-width: 120px !important;
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    vertical-align: middle !important;
  }
  #parlay .teamLogo{ width: 18px !important; height: 18px !important; }
}

@media (max-width: 380px){
  #parlay .teamName{ max-width: 105px !important; }
  #parlay .pillPick{ max-width: 96% !important; }
}



/* ---- Desktop centering v12 ---- */
#parlay .slipLeague,
#parlay .slipLeagueDT,
#parlay .slipLeagueSubDT{
  text-align: center;
  width: 100%;
}
#parlay .slipRow{
  text-align: center;
  align-items: center;
}
#parlay .pillPick{
  display: inline-block;
  margin: 10px auto 0;
  text-align: center;
  max-width: 92%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Teams row centered with 2 columns + VS center (desktop + mobile) */
#parlay .slipTeams{
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  justify-items: center;
  gap: 12px;
  width: 100%;
}
#parlay .slipTeams .teamChunk{
  width: 100%;
  min-width: 0;
  gap: 10px;
}
#parlay .slipTeams .teamChunk:first-child{ justify-content: flex-end; }
#parlay .slipTeams .teamChunk:last-child{ justify-content: flex-start; }
#parlay .vs{ margin: 0; opacity: .55; }

/* Avoid name wrapping on desktop too */
#parlay .teamName{
  display: inline-block;
  max-width: 220px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: middle;
}


  /* ===== PARLAY APP REDESIGN (UI ONLY) ===== */
  #parlayWrap.card{ background:transparent !important; border:none !important; box-shadow:none !important; padding:0 !important; }
  .parlay-app{
    width:min(980px, 96vw);
    margin: 14px auto 40px;
    padding: 14px 0 30px;
  }
  .parlay-hero{
    position:relative;
    padding: 18px 16px;
    border-radius: 18px;
    background: linear-gradient(180deg, rgba(2,6,23,.85), rgba(2,6,23,.65));
    border: 1px solid rgba(148,163,184,.22);
    box-shadow: 0 18px 40px rgba(0,0,0,.45);
    overflow:hidden;
  }
  .parlay-hero:before{
    content:"";
    position:absolute; inset:-2px;
    background:
      radial-gradient(900px 300px at 15% 10%, rgba(34,211,238,.18), transparent 55%),
      radial-gradient(900px 300px at 85% 15%, rgba(168,85,247,.16), transparent 58%),
      radial-gradient(900px 260px at 50% 120%, rgba(250,204,21,.12), transparent 60%);
    pointer-events:none;
  }
  .parlay-hero-title{
    position:relative;
    font-weight: 900;
    letter-spacing: .2px;
    font-size: clamp(18px, 3.6vw, 24px);
    color:#e5e7eb;
  }
  .parlay-hero-sub{
    position:relative;
    margin-top:6px;
    color: rgba(229,231,235,.82);
    font-size: 13px;
    line-height: 1.35;
  }
  .parlay-hero-actions{
    position:relative;
    margin-top: 12px;
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }
  .btn{
    appearance:none;
    border:none;
    border-radius: 999px;
    padding: 10px 14px;
    font-weight: 800;
    letter-spacing: .2px;
    background: rgba(34,211,238,.14);
    color:#e5e7eb;
    border:1px solid rgba(34,211,238,.35);
    cursor:pointer;
    transition: transform .08s ease, background .18s ease, border-color .18s ease;
    user-select:none;
  }
  .btn:hover{ transform: translateY(-1px); background: rgba(34,211,238,.18); border-color: rgba(34,211,238,.55); }
  .btn:active{ transform: translateY(0); }
  .btn.ghost{
    background: rgba(15,23,42,.55);
    border-color: rgba(148,163,184,.35);
  }
  .btn.ghost:hover{ background: rgba(15,23,42,.75); border-color: rgba(148,163,184,.55); }

  /* Ticket polish */
  #parlay .slipCard{
    margin-top: 14px;
    border-radius: 22px;
    padding: 16px 14px 14px;
    position:relative;
    overflow:hidden;
  }
  #parlay .slipCard:before{
    content:"";
    position:absolute; inset:0;
    background:
      radial-gradient(800px 260px at 10% 0%, rgba(99,102,241,.10), transparent 60%),
      radial-gradient(700px 240px at 90% 10%, rgba(34,211,238,.10), transparent 60%);
    pointer-events:none;
  }
  #parlay .slipRow{ position:relative; }
  #parlay .pillPick{
    border-radius: 999px;
    font-weight: 900;
    letter-spacing: .15px;
  }
  #parlay .slipOdd{
    margin-top: 14px;
    border-radius: 16px;
    padding: 12px 10px;
    position:relative;
  }

  /* Footer */
  .parlay-footer{
    margin-top: 12px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    flex-wrap:wrap;
    padding: 10px 4px;
  }
  .parlay-footer-note{
    color: rgba(229,231,235,.72);
    font-size: 12px;
  }

  /* Share Mode: hide header/sub + center ticket tighter */
  body.share-mode header,
  body.share-mode .topbar,
  body.share-mode #goTop,
  body.share-mode #warn{ display:none !important; }
  body.share-mode .parlay-app{ margin-top: 6px; }
  body.share-mode .parlay-hero{ display:none !important; }
  body.share-mode #parlay .slipCard{ box-shadow: 0 28px 60px rgba(0,0,0,.55); }

  /* Toast */
  .toast{
    position:fixed;
    left:50%;
    transform:translateX(-50%);
    bottom:14px;
    z-index: 99999;
    background: rgba(2,6,23,.92);
    border: 1px solid rgba(148,163,184,.35);
    color:#e5e7eb;
    padding: 10px 14px;
    border-radius: 999px;
    box-shadow: 0 18px 40px rgba(0,0,0,.5);
    font-weight: 800;
    font-size: 12px;
    opacity:0;
    pointer-events:none;
    transition: opacity .18s ease, transform .18s ease;
  }
  .toast.show{ opacity:1; transform:translateX(-50%) translateY(-2px); }

  /* Loading steps */
  .loading-steps{
    margin-top: 10px;
    display:grid;
    gap:6px;
    text-align:left;
    width:min(360px, 86vw);
  }
  .loading-step{
    display:flex;
    align-items:center;
    gap:10px;
    font-size: 12px;
    color: rgba(229,231,235,.82);
  }
  .loading-dot{
    width:10px;height:10px;border-radius:999px;
    border:1px solid rgba(148,163,184,.55);
    background: rgba(15,23,42,.65);
    box-shadow:none;
    flex:0 0 auto;
  }
  .loading-step.done .loading-dot{
    background: rgba(34,211,238,.22);
    border-color: rgba(34,211,238,.75);
    box-shadow: 0 0 18px rgba(34,211,238,.22);
  }
  .loading-step.active{ color:#e5e7eb; }
  .loading-step.active .loading-dot{
    background: rgba(250,204,21,.22);
    border-color: rgba(250,204,21,.75);
    box-shadow: 0 0 18px rgba(250,204,21,.20);
  }

  /* Intro phase label */
  #introOverlay .intro-phase{
    margin-top: 12px;
    display:inline-flex;
    gap:8px;
    align-items:center;
    padding: 6px 10px;
    border-radius: 999px;
    background: rgba(15,23,42,.65);
    border: 1px solid rgba(148,163,184,.35);
    font-weight: 800;
    font-size: 12px;
    color: rgba(229,231,235,.88
/* ================= PARLAY VISUAL v2 (no share/copy) ================= */
  .parlay-hero{
    padding: 22px 20px;
    border-radius: 22px;
    background:
      radial-gradient(900px 380px at 18% 10%, rgba(34,211,238,.20), transparent 55%),
      radial-gradient(900px 360px at 82% 18%, rgba(168,85,247,.18), transparent 58%),
      linear-gradient(180deg, rgba(2,6,23,.82), rgba(2,6,23,.62));
    border: 1px solid rgba(148,163,184,.18);
    box-shadow: 0 26px 70px rgba(0,0,0,.55);
  }
  .parlay-hero-title{
    font-size: 28px;
    letter-spacing: .2px;
    line-height: 1.1;
  }
  .parlay-hero-sub{
    margin-top: 8px;
    font-size: 13px;
    color: rgba(229,231,235,.80);
  }

  /* Ticket container (glass) */
  #parlay .slipCard{
    background:
      radial-gradient(900px 420px at 12% 0%, rgba(34,211,238,.10), transparent 60%),
      radial-gradient(900px 420px at 88% 0%, rgba(168,85,247,.10), transparent 60%),
      rgba(255,255,255,.06);
    color: #e5e7eb;
    border: 1px solid rgba(148,163,184,.22);
    backdrop-filter: blur(14px);
    -webkit-backdrop-filter: blur(14px);
    box-shadow: 0 24px 60px rgba(0,0,0,.55);
  }

  /* League header + date chips */
  #parlay .slipLeague{
    color: rgba(229,231,235,.70);
    border-top: 1px solid rgba(148,163,184,.14);
  }
  #parlay .slipLeagueDT,
  #parlay .slipLeagueSubDT,
  #parlay .pillTime{
    background: rgba(2,6,23,.40);
    border: 1px solid rgba(148,163,184,.18);
    color: rgba(229,231,235,.90);
  }

  /* Pick pill */
  #parlay .pillPick{
    background: rgba(2,6,23,.72);
    border: 1px solid rgba(148,163,184,.20);
  }

  /* Teams */
  #parlay .teamLogo{ box-shadow: 0 8px 18px rgba(0,0,0,.35); }
  .teamLogoFallback{
    background: rgba(2,6,23,.45);
    border: 1px solid rgba(148,163,184,.18);
    color: rgba(229,231,235,.85);
  }

  /* Odd bar */
  #parlay .slipOdd{
    background: linear-gradient(135deg, rgba(34,211,238,.92), rgba(168,85,247,.92));
    color: #071018;
    letter-spacing: .2px;
    border: 1px solid rgba(255,255,255,.22);
    box-shadow: 0 18px 38px rgba(34,211,238,.20), 0 18px 38px rgba(168,85,247,.18);
  }

  /* Hide share/copy remnants if any */
  #btnShareMode,#btnCopyParlay{ display:none !important; }
  .parlay-hero-actions{ display:none !important; }
  .toast{ display:none !important; }

  /* Top button polish */
  .parlay-fab{
    background: rgba(255,255,255,.06);
    border: 1px solid rgba(148,163,184,.22);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  @media (max-width:520px){
    .parlay-hero-title{ font-size: 22px; }
    .parlay-hero{ padding: 16px 14px; border-radius: 18px; }
    #parlay .slipCard{ border-radius: 18px; }
  }



/* ===== MODERN DARK GLASS PARLAY (v3) ===== */
#parlay .slipCard{
  background: linear-gradient(180deg, rgba(15,23,42,.72), rgba(2,6,23,.72));
  color:#e5e7eb;
  border:1px solid rgba(148,163,184,.20);
  box-shadow: 0 30px 80px rgba(0,0,0,.55), 0 0 0 1px rgba(255,255,255,.05) inset;
  backdrop-filter: blur(16px);
}
#parlay .slipLeague{ color:rgba(199,210,254,.85); border-top:1px solid rgba(148,163,184,.14); }
#parlay .slipLeagueDT, #parlay .slipLeagueSubDT{
  background:rgba(148,163,184,.12);
  color:rgba(226,232,240,.92);
  border:1px solid rgba(148,163,184,.20);
}
#parlay .slipRow{
  border-radius:16px;
  background:rgba(2,6,23,.35);
  border:1px solid rgba(148,163,184,.12);
  margin-top:10px;
}
#parlay .slipTeams{ font-size:15px;font-weight:850; }
#parlay .teamLogo{ box-shadow:0 8px 18px rgba(0,0,0,.35); }
#parlay .pillTime{
  background:rgba(148,163,184,.12);
  color:#e5e7eb;
  border:1px solid rgba(148,163,184,.18);
}
#parlay .pillPick{
  background: linear-gradient(135deg, rgba(34,211,238,.22), rgba(168,85,247,.18));
  border:1px solid rgba(34,211,238,.30);
  color:#e5e7eb;
}
#parlay .slipOdd{
  background: linear-gradient(135deg, rgba(250,204,21,1), rgba(245,158,11,1));
  color:#0b1220;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
}
#parlay .slipNote{ color:rgba(148,163,184,.92); }



/* === HEADER POLISH (CENTERED) === */
header{
  text-align:center;
}
h1.brand{
  justify-content:center;
}
header .sub{
  text-align:center;
}
/* Premium brand lockup */
h1.brand{
  display:inline-flex;
  padding:10px 16px;
  border-radius:999px;
  background:rgba(255,255,255,.04);
  border:1px solid rgba(255,255,255,.10);
  box-shadow:0 14px 40px rgba(0,0,0,.35);
}
header{
  padding:18px 18px;
}


/* === FINAL OVERRIDES (V9) === */
/* Header: centered lockup to match parlay aesthetic */
header{
  display:flex !important;
  flex-direction:column !important;
  align-items:center !important;
  justify-content:center !important;
  text-align:center !important;
  gap:6px !important;
}
header h1.brand{
  margin:0 auto !important;
  justify-content:center !important;
  align-items:center !important;
}
header .sub{
  margin:0 !important;
  text-align:center !important;
  width:100% !important;
}

/* League date/time chips: force true center */
#parlay .slipLeagueDT,
#parlay .slipLeagueSubDT{
  width:100% !important;
  justify-content:center !important;
  text-align:center !important;
}

/* Team logos: slightly larger */
#parlay .teamLogo,
#parlay .teamLogoFallback{
  width:22px !important;
  height:22px !important;
}
@media (max-width: 520px){
  #parlay .teamLogo,
  #parlay .teamLogoFallback{
    width:18px !important;
    height:18px !important;
  }
}
</style>
<style id="v10_final_overrides">
/* ===== V10 FINAL: force center header + center DT chips + slightly larger logos ===== */
header{
  position:sticky !important;
  top:0 !important;
  left:0 !important;
  right:0 !important;
  width:100% !important;
  display:flex !important;
  flex-direction:column !important;
  align-items:center !important;
  justify-content:center !important;
  text-align:center !important;
  gap:6px !important;
}
header h1.brand{
  margin:0 auto !important;
  justify-content:center !important;
  align-items:center !important;
  text-align:center !important;
  width:fit-content !important;
}
header .sub{
  margin:0 !important;
  width:100% !important;
  text-align:center !important;
  opacity:.88 !important;
}

/* Date/time chips: centered */
#parlay .slipLeagueDT,
#parlay .slipLeagueSubDT{
  display:block !important;
  width:fit-content !important;
  margin:10px auto 0 auto !important;
  text-align:center !important;
}

/* If any DT chips are inside wrappers, center wrappers too */
#parlay .slipMeta,
#parlay .slipRow{
  text-align:center !important;
}

/* Logos slightly bigger (but not too much) */
#parlay .teamLogo{
  width:22px !important;
  height:22px !important;
}
@media (max-width: 520px){
  #parlay .teamLogo{ width:18px !important; height:18px !important; }
}

/* ===== Header v11 (premium lockup) ===== */
header.topbar{
  position:sticky;
  top:0;
  z-index:200;
  padding:18px 14px 16px;
  background:
    radial-gradient(900px 240px at 50% -30%, rgba(34,211,238,.16), transparent 55%),
    linear-gradient(180deg, rgba(2,6,23,.92), rgba(2,6,23,.72));
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  border-bottom: 1px solid rgba(148,163,184,.16);
}

.topbar-inner{
  max-width: 980px;
  margin: 0 auto;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:8px;
}

.brand-lock{
  display:flex;
  align-items:center;
  justify-content:center;
  gap:10px;
  padding:10px 14px;
  border-radius:999px;
  background: rgba(255,255,255,.06);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow:
    0 10px 30px rgba(0,0,0,.35),
    0 0 0 1px rgba(255,255,255,.04) inset;
}

.brand-name{
  font-weight: 900;
  letter-spacing: .3px;
  font-size: 22px;
  line-height: 1;
  background: linear-gradient(90deg, var(--brand), #60a5fa, var(--brand));
  background-size: 200% 100%;
  -webkit-background-clip:text;
  background-clip:text;
  color: transparent;
  animation: shift 6s linear infinite;
}

header.topbar .mini-logo{
  width: 22px;
  height: 22px;
  object-fit: contain;
  filter: drop-shadow(0 10px 22px rgba(0,0,0,.55));
}

header.topbar .sub{
  margin:0;
  text-align:center !important;
  font-size: 12.5px;
  letter-spacing: .2px;
  color: rgba(226,232,240,.72);
}

.topbar-accent{
  width: min(520px, 86vw);
  height: 1px;
  border-radius: 999px;
  background: linear-gradient(90deg, transparent, rgba(34,211,238,.55), rgba(168,85,247,.45), transparent);
  opacity: .9;
}

@media (max-width: 560px){
  header.topbar{ padding: 14px 12px 12px; }
  .brand-name{ font-size: 20px; }
  header.topbar .mini-logo{ width: 20px; height: 20px; }
  header.topbar .sub{ font-size: 12px; }
  .brand-lock{ padding: 9px 12px; }
}

</style>
<style>
header h1.brand{
  justify-content:center !important;
  font-size:32px !important;
}
.mini-logo{
  width:32px !important;
  height:32px !important;
}
#parlayWrap{
  position:relative;
}
#parlayWrap::before{
  content:'';
  position:absolute;
  inset:0;
  background:url('https://i.ibb.co/SXH1pjJT/412922055-848949337239315-5232796371347865039-n-removebg-preview.png') center center / contain no-repeat;
  opacity:0.04;
  pointer-events:none;
}
.parlay-items{
  background:rgba(12,18,38,.82) !important;
  border-radius:18px !important;
}
.parlay-pill{
  margin-left:auto !important;
  margin-right:auto !important;
  text-align:center !important;
}
.slipLeagueSubDT,
.slipLeagueDT{
  text-align:center !important;
}
</style><style>
#parlayWrap::before{
  content:'' !important;
  position:fixed !important;
  inset:0 !important;
  background:url('https://i.ibb.co/SXH1pjJT/412922055-848949337239315-5232796371347865039-n-removebg-preview.png') center center / 600px 600px no-repeat !important;
  opacity:0.03 !important;
  pointer-events:none !important;
  z-index:1 !important;
}
#parlay{
  position:relative !important;
  z-index:5 !important;
}
</style></head>
<body>
<!-- Intro / Splash (sempre no arranque) -->
<div aria-hidden="true" id="introOverlay">
<div class="intro-inner">
<img alt="LuxTIPS" class="intro-logo" src="https://i.ibb.co/SXH1pjJT/412922055-848949337239315-5232796371347865039-n-removebg-preview.png"/>
<div class="intro-title">LuxTIPS</div>
<div class="intro-slogan">Prognósticos com foco em alta precisão</div>
<div class="intro-progress">
<div class="intro-progress-bar"><div class="intro-progress-fill" id="introBarFill"></div></div>
<div class="intro-progress-meta">
<span class="intro-progress-text" id="introStatus">Inicializar motor…</span>
<span class="intro-progress-pct" id="introPercent">0%</span>
</div>
</div>
</div>
</div>
<header class="topbar">
<div class="topbar-inner">
<div aria-label="LuxTIPS" class="brand-lock">
<img alt="LuxTIPS" class="mini-logo" src="https://i.ibb.co/SXH1pjJT/412922055-848949337239315-5232796371347865039-n-removebg-preview.png"/>
<div class="brand-name">LuxTIPS</div>
</div>
<div class="sub">Prognósticos Futebol · High Accuracy Engine</div>
<div aria-hidden="true" class="topbar-accent"></div>
</div>
</header>
<main>
<div class="loading-overlay" id="loadingOverlay" style="display:none;">
<div class="loading-card">
<div class="loading-spinner"></div>
<div class="loading-text">A carregar dados....</div>
<div class="loading-steps" id="loadingSteps"></div>
<div class="loading-bar">
<div class="loading-bar-fill"></div>
</div>
<div class="loading-percent" id="loadingPercent">0%</div>
</div>
</div>
<div class="card" id="fileCard" style="display:block">
<div class="row">
<div>
<label>Fixtures (XLSX/CSV)</label><br/>
<input accept=".xlsx,.xls,.csv" id="fixturesFile" multiple="" type="file"/>
</div>
<div>
<label>Histórico (XLSX/CSV — múltiplos)</label><br/>
<input accept=".xlsx,.xls,.csv" id="historyFiles" multiple="" type="file"/>
</div>
<!-- CONTROLOS FIXOS (ocultos, valores predefinidos) -->
<div style="display:none">
<label>Banca (€)</label><br/>
<input id="bankroll" step="0.01" style="width:120px" type="number" value="1000"/>
</div>
<div style="display:none">
<label>Odd alvo da múltipla</label><br/>
<input id="targetParlay" step="0.1" style="width:100px" type="number" value="6"/>
</div>
<div style="display:none">
<label>Top-5 (E0, SP1, I1, D1, F1): nº épocas</label><br/>
<input id="nTop5" max="15" min="1" style="width:80px" type="number" value="5"/>
</div>
<div style="display:none">
<label>Médias (P1, NL1, BR, SE,…): nº épocas</label><br/>
<input id="nMed" max="15" min="1" style="width:80px" type="number" value="3"/>
</div>
<div style="display:none">
<label>Segundas divisões (I2, F2, D2, E1,…): nº épocas</label><br/>
<input id="nSeg" max="15" min="1" style="width:80px" type="number" value="2"/>
</div>
<div style="display:none">
<label>Decaimento temporal</label><br/>
<select id="decayPreset" style="width:160px">
<option value="none">Sem decaimento (1.00)</option>
<option value="soft">Suave (×0.80)</option>
<option value="medium">Médio (×0.70)</option>
<option selected="" value="strong">Forte (×0.60)</option>
</select>
</div>
<div style="display:none">
<label>Bayes α (suavização)</label><br/>
<input id="bayesAlpha" min="0" step="1" style="width:90px" type="number" value="120"/>
</div>
<div style="display:none;flex:1">
<label>Overrides por liga (ex.: E0:6, I2:3)</label><br/>
<input id="overrides" placeholder="Códigos Div:épocas, separados por vírgula" style="width:100%" type="text" value=""/>
</div>
</div>
<!-- FAMÍLIAS e OPCIONAIS (ocultos mas mantidos) -->
<div style="display:none;margin-top:8px">
<span class="tog"><input checked="" id="famRESULTADO" type="checkbox"/> <label for="famRESULTADO">Resultado (DNB/DC)</label></span>
<span class="tog"><input checked="" id="famTOTAL" type="checkbox"/> <label for="famTOTAL">Totais (Over/Under)</label></span>
<span class="tog"><input checked="" id="famBTTS" type="checkbox"/> <label for="famBTTS">BTTS</label></span>
<span class="tog"><input checked="" id="famAH" type="checkbox"/> <label for="famAH">Asian Handicap</label></span>
<span class="tog"><label>Máx por família:</label> <input id="maxPorFam" max="6" min="1" style="width:60px" type="number" value="2"/></span>
<span class="tog"><input checked="" id="onlyHigh" type="checkbox"/> <label for="onlyHigh">Só confianças altas (≥ 72%)</label></span>
<span class="tog"><input id="useKelly" type="checkbox"/> <label for="useKelly">Usar Kelly (teto do stake)</label></span>
<span class="tog"><input checked="" id="corrFLB" type="checkbox"/> <label for="corrFLB">Corrigir Favourite-Longshot Bias</label></span>
<span class="tog"><label>1X2 — modo:</label>
<select id="mode1x2">
<option selected="" value="prob">Mais provável</option>
<option value="ev">Valor esperado (EV+)</option>
</select>
</span>
</div>
<div class="row" style="margin-top:10px">
<span class="tog" style="display:flex;align-items:center;gap:10px">
<label style="font-size:12px;color:#c7d2fe;display:flex;align-items:center;gap:8px">
<input checked="" id="forceToday" type="checkbox"/>
          Filtrar por ciclo (Sex–Seg / Ter–Qui)
        </label>
</span>
<span class="tog"><button id="runBtn">Gerar prognósticos</button></span>
<span class="tog"><button class="btn-s" id="expAll">Exportar picks (CSV)</button></span>
<span class="tog"><button class="btn-s" id="exp1x2">Exportar 1X2 (CSV)</button></span>
<span class="tog"><button class="btn-s" id="copyExcel">Copiar p/ Excel</button></span>
</div>
<div id="warn" style="margin-top:8px;color:#fbbf24;font-size:12px;display:none"></div>
<!-- Tabs fixas para navegar entre as secções de resultados -->
<div class="results-tabs" id="resultsTabs" style="display:none">
<button class="tab-btn tab-active" data-target="picksWrap" type="button">Picks</button>
<button class="tab-btn" data-target="best1x2Wrap" type="button">1X2</button>
<button class="tab-btn" data-target="parlayWrap" type="button">Múltipla</button>
</div>
</div>
<div class="card" id="summary" style="display:none"></div>
<div class="card" id="calib" style="display:none"></div>
<div class="card" id="picksWrap" style="display:none">
<h3>🔝 Picks sugeridas</h3>
<div id="picks"></div>
</div>
<div class="card" id="best1x2Wrap" style="display:none">
<h3>💠 Melhores picks de 1X2</h3>
<div id="best1x2"></div>
</div>
<div class="card" id="parlayWrap" style="display:none">
<div class="parlay-app">
</div>
<div id="parlay"></div>
<div class="parlay-footer" id="parlayFooter" style="display:none">
</div>
</div>
</main>
<script>
/* === Cloudflare Worker proxy (Opção B) === */
const CF_WORKER = "https://luxtips.90carlosmachado.workers.dev/";
const PROXY_KEY = "506588459";

// ===== Helpers =====
const clamp01=x=>Math.max(0,Math.min(1,x));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const pct=x=>(100*x).toFixed(1)+"%";
const capEV = ev => ev; // sem truncar
const MIN_ODD = 1.01;

// Se false, só mostra mercados com odd REAL vinda do ficheiro (sem \"inventar\" odds).
const ALLOW_ESTIMATED_ODDS = true; // permitir odds derivadas quando não existem no ficheiro
const MIN_ODD_1X2 = 1.30; // para 1X2 (igual ao ficheiro de referência)

const MIN_PROB_1X2 = 0.70;   // prob. mínima para 1X2 focado em alta taxa de acerto
const MIN_EV_1X2   = -0.50;  // permite algum EV negativo, foco na probabilidade

const SAFE_1X2_DIV = new Set([
  'E0', // Premier League
  'SP1',// La Liga
  'D1', // Bundesliga
  'I1', // Serie A
  'F1', // Ligue 1
  'P1',
'BRA','ARG','USA','DNK','ROU','NOR','SWE','AUT','CHN','FIN','IRL','JPN','MEX','POL','RUS','SWZ'
]);


// price a partir de probabilidade com margem do book (vig)

// mistura modelo vs mercado (1X2 implícito) para manter alinhamento com odds reais
function blendProb(modelP, marketP, wModel=0.65){
  const m = clamp01(modelP);
  const k = clamp01(marketP);
  return clamp01(wModel*m + (1-wModel)*k);
}

function priceFromProb(prob, margin=0.05){
  // margem do book: odds piores do que a justa (mais realista)
  return 1 / Math.max(0.01, prob * (1 + margin));
}

// === odds REAIS (mapeamento de colunas) ===
const COLS = {
  OVER25:  ['Over25','Over 2.5','O25','Over2_5','B365>2.5','Avg>2.5'],
  OVER15:  ['Over15','Over 1.5','O15','Over1_5','B365>1.5','Avg>1.5'],
  UNDER25: ['Under25','Under 2.5','U25','Under2_5','B365<2.5','Avg<2.5'],
  BTTS_Y:  ['BTTS_Y','BTTS Yes','BTSY','GG','BothTeamsToScore_Yes'],
  BTTS_N:  ['BTTS_N','BTTS No','BTSN','NG','BothTeamsToScore_No'],
  AHm1_H:  ['AH-1_H','AH(-1) Home','AHm1H','AH_-1_H','B365AH-1_H'],
  AHm1_A:  ['AH-1_A','AH(-1) Away','AHm1A','AH_-1_A','B365AH-1_A'],
  AHm15_H: ['AH-1.5_H','AH(-1.5) Home','AHm15H','B365AH-1.5_H'],
  AHm15_A: ['AH-1.5_A','AH(-1.5) Away','AHm15A','B365AH-1.5_A'],
  AHp05_H: ['AH+0.5_H','AH(+0.5) Home','AHp05H','B365AH+0.5_H'],
  AHp05_A: ['AH+0.5_A','AH(+0.5) Away','AHp05A','B365AH+0.5_A']
};
function readOdd(row, keys){
  if(!keys || typeof keys[Symbol.iterator] !== 'function') return null;
  for(const k of keys){
    const v = parseFloat(row[k]);
    if(!isNaN(v) && v > 1.01) return v;
  }
  return null;
}

async function loadXLSX(){ if(window.XLSX) return window.XLSX; const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js'; const p=new Promise((res,rej)=>{ s.onload=()=>res(); s.onerror=()=>rej(new Error('Falha a carregar XLSX (precisa internet).')); }); document.head.appendChild(s); await p; return window.XLSX; }
function parseCSV(text){ const noCR=text.split('\r').join(''); const lines=noCR.split('\n').filter(x=>x.trim().length); if(!lines.length) return []; const headRaw=lines[0]; const sep=headRaw.indexOf(';')>-1?';':','; const header=headRaw.split(sep).map(s=>s.trim()); const rows=[]; for(let i=1;i<lines.length;i++){ const parts=lines[i].split(sep); if(parts.length<2) continue; const o={}; header.forEach((h,idx)=>o[h]=parts[idx]!==undefined?parts[idx].trim():""); rows.push(o);} return rows; }
// === XLSX/CSV reading (anti-loop + performance) ===
async function readCSVFile(file){
  const txt = await file.text();
  return parseCSV(txt);
}

function _sheetToRows(sheet, maxRows){
  if(!sheet) return [];
  const XLSX = window.XLSX;
  try{
    if(sheet['!ref']){
      const rg = XLSX.utils.decode_range(sheet['!ref']);
      // limit rows (0-indexed). keep header row inside range.
      rg.e.r = Math.min(rg.e.r, Math.max(0, maxRows-1));
      const ref = XLSX.utils.encode_range(rg);
      return XLSX.utils.sheet_to_json(sheet, { defval:'', blankrows:false, raw:true, range: ref });
    }
  }catch(e){}
  // fallback
  return XLSX.utils.sheet_to_json(sheet, { defval:'', blankrows:false, raw:true });
}

// Prefer to read ONLY the "fixtures" sheet when present (Football-Data updated files can include many sheets).
async function readAnyFixtures(file){
  const name = (file.name||'').toLowerCase();
  if(name.endsWith('.csv')) return readCSVFile(file);

  const XLSX = await loadXLSX();
  const buf = await file.arrayBuffer();
  const wb = XLSX.read(buf, { type:'array' });

  const preferred = ['fixtures','Fixtures','FIXTURES'];
  let sheetName = null;
  for(const p of preferred){
    if(wb.SheetNames.includes(p)){ sheetName = p; break; }
  }
  if(!sheetName) sheetName = wb.SheetNames[0];

  const sheet = wb.Sheets[sheetName];
  let rows = _sheetToRows(sheet, 8000);

  // Light filter to avoid garbage rows
  rows = rows.filter(r => r && (r.HomeTeam || r.Home) && (r.AwayTeam || r.Away));
  return rows;
}

// History files often have multiple sheets (one per division). We read all sheets, but with strict caps.
async function readAnyHistory(file){
  const name = (file.name||'').toLowerCase();
  if(name.endsWith('.csv')) return readCSVFile(file);

  const XLSX = await loadXLSX();
  const buf = await file.arrayBuffer();
  const wb = XLSX.read(buf, { type:'array' });

  const MAX_SHEETS = 120;
  const MAX_TOTAL_ROWS = 450000;
  const PER_SHEET_CAP = 120000;

  const out = [];
  const names = wb.SheetNames.slice(0, MAX_SHEETS);

  for(const n of names){
    const sheet = wb.Sheets[n];
    if(!sheet) continue;

    // Convert with row cap to avoid huge formatted ranges
    let rows = _sheetToRows(sheet, PER_SHEET_CAP);

    // Filter early: keep only match-like rows
    rows = rows.filter(r =>
      r &&
      (r.Div || r.Country) &&
      (r.HomeTeam || r.Home) &&
      (r.AwayTeam || r.Away) &&
      (r.Date || r.Data || r.MatchDate || r.FDate || r.Year)
    );

    if(rows.length){
      out.push(...rows);
      if(out.length >= MAX_TOTAL_ROWS) break;
    }
  }
  return out;
}

function excelSerialToDate(v){ const ms=(v - 25569) * 86400 * 1000; return new Date(ms); }
function isDigits(s){ for(let i=0;i<s.length;i++){ const c=s.charCodeAt(i); if(c<48||c>57) return false;} return true; }
function isIsoDate(str){ return (str.length>=10 && str[4]=='-' && str[7]=='-' && isDigits(str.slice(0,4)) && isDigits(str.slice(5,7)) && isDigits(str.slice(8,10))); }
function isDMYDate(str){ return (str.length>=10 && str[2]=='/' && str[5]=='/' && isDigits(str.slice(0,2)) && isDigits(str.slice(3,5)) && isDigits(str.slice(6,10))); }
function parseDateStr(s){ if(s===undefined||s===null) return ''; if(s instanceof Date) return s; if(typeof s==='number'&&!isNaN(s)) return excelSerialToDate(s); if(typeof s==='object'&&s.w){ return parseDateStr(String(s.w)); } const t=String(s).trim(); let d=null; if(isIsoDate(t)){ const parts=t.split(' '); const date=parts[0], time=parts[1]||''; d=time?new Date(date+'T'+time):new Date(date+'T12:00'); } else if(isDMYDate(t)){ const parts=t.split(' '); const date=parts[0], time=parts[1]||''; const dd=date.slice(0,2), mm=date.slice(3,5), yy=date.slice(6,10); d=time?new Date(yy+'-'+mm+'-'+dd+'T'+time):new Date(yy+'-'+mm+'-'+dd+'T12:00'); } return (d&&!isNaN(d))?d:''; }
const CALENDAR_DIVS = new Set([
  'ARG','BRA','CHN','FIN','IRL','JPN','NOR','SWE','USA'
]);

const COUNTRY_TO_DIV = {
  'Argentina':'ARG',
  'Austria':'AUT',
  'Brazil':'BRA',
  'China':'CHN',
  'Denmark':'DNK',
  'Denmark ':'DNK',
  'Finland':'FIN',
  'Finland ':'FIN',
  'Ireland':'IRL',
  'Ireland ':'IRL',
  'Japan':'JPN',
  'Mexico':'MEX',
  'Norway':'NOR',
  'Poland':'POL',
  'Romania':'ROU',
  'Russia':'RUS',
  'Sweden':'SWE',
  'Sweden ':'SWE',
  'Switzerland':'SWZ',
  'USA':'USA'
};

function seasonKeyFromDate(d, div){
  if(!(d instanceof Date) || isNaN(d)) return '';
  const y=d.getFullYear(), m=d.getMonth()+1;
  if (div && CALENDAR_DIVS.has(String(div).toUpperCase())){
    return String(y);
  }
  return (m>=7)? (y+'/'+(y+1)) : ((y-1)+'/'+y);
}
function parseHistDate(row){
  const raw=row.Date||row.Data||row.MatchDate||row.FDate||'';
  if(raw instanceof Date) return raw;
  if(typeof raw==='number'&&!isNaN(raw)) return excelSerialToDate(raw);
  if(typeof raw==='string' && raw.trim()){ const d=parseDateStr(raw); if(d) return d; }
  if(row.Year && row.Month && row.Day){ return new Date(+row.Year, +row.Month-1, +row.Day); }
  return '';
}
function timeHMFromRow(row){
  const raw = (row.Time ?? row.Kickoff ?? row.Hour ?? row.Hora ?? '');
  const pad=n=>String(n).padStart(2,'0');
  if(raw instanceof Date){
    return {hh: raw.getHours(), mm: raw.getMinutes(), str: pad(raw.getHours())+':'+pad(raw.getMinutes())};
  }
  if(typeof raw === 'number' && !isNaN(raw)){
    // Excel time = fração do dia (0–1)
    const totalMinutes = Math.round(raw * 24 * 60);
    const hh = Math.floor(totalMinutes / 60) % 24;
    const mm = totalMinutes % 60;
    return {hh, mm, str: pad(hh)+':'+pad(mm)};
  }
  if(raw && typeof raw === 'object' && 'w' in raw){
    const s = String(raw.w).trim();
    const m = s.match(/(\d{1,2})[:.](\d{2})/);
    if(m){ const hh=+m[1], mm=+m[2]; return {hh,mm,str:pad(hh)+':'+pad(mm)}; }
    return {hh:0,mm:0,str:s};
  }
  if(typeof raw === 'string'){
    const s = raw.trim();
    const m = s.match(/(\d{1,2})[:.](\d{2})/);
    if(m){ const hh=+m[1], mm=+m[2]; return {hh,mm,str:pad(hh)+':'+pad(mm)}; }
    return {hh:0,mm:0,str:s};
  }
  return null;
}

function dtLabelFromRow(row){
  const dateRaw = row.Date || row.Data || row.MatchDate || '';
  let d=parseDateStr(dateRaw);
  const pad=n=>String(n).padStart(2,'0');
  if(!d) return dateRaw?String(dateRaw):'-';
  const t = timeHMFromRow(row);
  const datePart = `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${d.getFullYear()}`;
  if(!t || !t.str) return datePart;
  return `${datePart} ${t.str}`;
}

function tsFromRow(row){
  const dateRaw = row.Date || row.Data || row.MatchDate || '';
  let d=parseDateStr(dateRaw);
  if(!d) return 0;
  const t = timeHMFromRow(row);
  if(t && Number.isFinite(t.hh) && Number.isFinite(t.mm)){
    d.setHours(t.hh, t.mm, 0, 0);
  } else {
    d.setHours(12,0,0,0);
  }
  return d.getTime();
}

function estimateStatsFromGoals(row){
  // Se já houver estatísticas reais, não mexemos
  const hasReal =
    (row.HS || row.AS || row.HST || row.AST ||
     row.HC || row.AC || row.HF || row.AF ||
     row.HY || row.AY || row.HR || row.AR);

  if (hasReal) return row;

  // Golos (full-time) – usar também HG/AG se for esse o nome
  const hg = Number(row.FTHG || row.HG || 0);
  const ag = Number(row.FTAG || row.AG || 0);

  // Parâmetros médios
  const shotsPerGoal  = 7;     // remates por golo
  const sotRatio      = 0.35;  // % remates enquadrados
  const cornersRatio  = 0.23;  // % remates que geram cantos
  const foulsBase     = 10;    // faltas típicas por equipa

  // Remates
  row.HS  = Math.max(1, Math.round(hg * shotsPerGoal));
  row.AS  = Math.max(1, Math.round(ag * shotsPerGoal));

  // Remates enquadrados
  row.HST = Math.max(1, Math.round(row.HS * sotRatio));
  row.AST = Math.max(1, Math.round(row.AS * sotRatio));

  // Cantos
  row.HC  = Math.max(1, Math.round(row.HS * cornersRatio));
  row.AC  = Math.max(1, Math.round(row.AS * cornersRatio));

  // Faltas
  row.HF  = foulsBase + Math.round(Math.random()*3);
  row.AF  = foulsBase + Math.round(Math.random()*3);

  // Cartões amarelos (1 por cada ~7 faltas)
  row.HY  = Math.round(row.HF / 7);
  row.AY  = Math.round(row.AF / 7);

  // Vermelhos – raros
  row.HR  = Math.random() < 0.05 ? 1 : 0;
  row.AR  = Math.random() < 0.05 ? 1 : 0;

  return row;
}


// ===== Ligas e tiers =====
const TIER_TOP5 = new Set(['E0','SP1','I1','D1','F1']);
const TIER_SECOND = new Set(['I2','F2','D2','E1','SP2','NL2','P2','B2','G2']); 
const LIGA_REGRAS={
  'E0':{nome:'Premier League', prefer:['OVER','BTTS'], evitar:['UNDER']},
  'SP1':{nome:'La Liga', prefer:['UNDER'], evitar:['OVER']},
  'D1':{nome:'Bundesliga', prefer:['OVER','BTTS'], evitar:['UNDER']},
  'I1':{nome:'Serie A', prefer:['MISTO'], evitar:[]},
  'I2':{nome:'Serie B', prefer:['UNDER'], evitar:['OVER']},
  'NL1':{nome:'Eredivisie', prefer:['OVER','BTTS'], evitar:['UNDER']},
  'F1':{nome:'Ligue 1', prefer:['UNDER'], evitar:[]},
  'F2':{nome:'Ligue 2', prefer:['UNDER'], evitar:['OVER']},
  'P1':{nome:'Primeira Liga', prefer:['UNDER'], evitar:['OVER']},
  'SE':{nome:'Escandinávia', prefer:['OVER','BTTS'], evitar:['UNDER']},
  'BR':{nome:'Brasileirão', prefer:['UNDER'], evitar:['OVER']}
};

const MIN_PROB_FAM = {
  RESULTADO: 0.66,
  AH:        0.64,
  TOTAL:     0.55,
  BTTS:      0.55
};

const MIN_EV_FAM = {
  RESULTADO: -0.15,
  AH:        -0.15,
  TOTAL:     -0.20,
  BTTS:      -0.20
};

// Nome de liga baseado em País + divisão (regra geral)
const DIV_TO_NAME = {
  // England
  'E0': 'Premier League',
  'E1': 'EFL Championship',
  'E2': 'EFL League One',
  'E3': 'EFL League Two',
  'EC': 'National League',
  // Scotland
  'SC0': 'Scottish Premiership',
  'SC1': 'Scottish Championship',
  'SC2': 'Scottish League One',
  'SC3': 'Scottish League Two',
  // Germany
  'D1': 'Bundesliga',
  'D2': '2. Bundesliga',
  // Spain
  'SP1': 'La Liga',
  'SP2': 'La Liga 2',
  // Italy
  'I1': 'Serie A',
  'I2': 'Serie B',
  // France
  'F1': 'Ligue 1',
  'F2': 'Ligue 2',
  // Portugal
  'P1': 'Primeira Liga',
  // Netherlands
  'NL1':'Eredivisie',
  // Belgium
  'B1': 'Jupiler Pro League',
  // Greece
  'G1': 'Super League Greece',
  // Norway
  'N1': 'Eliteserien',
  // Turkey
  'T1': 'Süper Lig',
  // Brazil (Europa file)
  'BR': 'Campeonato Brasileiro Série A',
  // Sweden (Europa file)
  'SE': 'Allsvenskan',

  // World extra leagues (new_leagues_data)
  'ARG': 'Primera División Argentina',
  'AUT': 'Austrian Bundesliga',
  'BRA': 'Campeonato Brasileiro Série A',
  'CHN': 'Chinese Super League',
  'DNK': 'Danish Superliga',
  'FIN': 'Veikkausliiga',
  'IRL': 'League of Ireland Premier Division',
  'JPN': 'J1 League',
  'MEX': 'Liga MX',
  'NOR': 'Eliteserien',
  'POL': 'Ekstraklasa',
  'ROU': 'Liga I',
  'RUS': 'Russian Premier League',
  'SWE': 'Allsvenskan',
  'SWZ': 'Swiss Super League',
  'USA': 'Major League Soccer'
};
const COUNTRY_PREFIX = [
  ['SC', 'Escócia'],
  ['SP', 'Espanha'],
  ['E',  'Inglaterra'],
  ['D',  'Alemanha'],
  ['I',  'Itália'],
  ['F',  'França'],
  ['B',  'Bélgica'],
  ['G',  'Grécia'],
  ['N',  'Noruega'],
  ['T',  'Turquia'],
  ['P',  'Portugal'],
  ['NL', 'Países Baixos'],
  ['SE', 'Suécia'],
  ['BR', 'Brasil']
];
function ligaNameFromDiv(div){
  if(!div) return '-';
  const d = String(div).toUpperCase();
  if(DIV_TO_NAME[d]) return DIV_TO_NAME[d];
  if(LIGA_REGRAS[d] && LIGA_REGRAS[d].nome) return LIGA_REGRAS[d].nome;
  return d;
}

// Nome da liga para mostrar no UI (usa mapeamento fixo; senão infere por prefixo)
function ligaNome(div){
  return ligaNameFromDiv(div);
}


// ===== Model bits =====
function implied1x2(row){
  const sets=[['B365H','B365D','B365A'],['AvgH','AvgD','AvgA']];
  for(const [h,d,a] of sets){
    const oh=+row[h], od=+row[d], oa=+row[a];
    if(oh>0&&od>0&&oa>0){
      const invH=1/oh, invD=1/od, invA=1/oa;
      const s=invH+invD+invA;
      return {H:invH/s, D:invD/s, A:invA/s, src:[h,d,a].join('/'), odds:{H:oh,D:od,A:oa}};
    }
  }
  return null;
}
function parseOverrides(text){
  const map={};
  const t=(text||'').trim(); if(!t) return map;
  t.split(',').forEach(pair=>{
    const p=pair.trim(); if(!p) return;
    const [div,nv]=p.split(':');
    const n=parseInt((nv||'').trim(),10);
    if(div && !isNaN(n) && n>0) map[div.trim()]=n;
  });
  return map;
}
function decayWeight(rank, preset){
  if(preset==='none') return 1.0;
  const base = (preset==='strong')?0.60:(preset==='medium')?0.70:0.80;
  return Math.pow(base, rank);
}
async function computeLeagueCalib(histRows, opts){
  const out={}; if(!histRows.length) return out;
  const overrides=parseOverrides(opts.overrides||'');
  const nTop5=opts.nTop5||5, nMed=opts.nMed||4, nSeg=opts.nSeg||3, preset=opts.decayPreset||'soft';
  const alpha = Math.max(0, +opts.bayesAlpha || 0);
  const byDivSeason={}; let glob={n:0,homeWins:0,over25:0,btts:0};
  for(const r of histRows){
    const div=r.Div; if(!div) continue;
    const d=parseHistDate(r); if(!d) continue;
    const sk=seasonKeyFromDate(d, div); if(!sk) continue;
    if(!byDivSeason[div]) byDivSeason[div]={}; if(!byDivSeason[div][sk]) byDivSeason[div][sk]={n:0,homeWins:0,over25:0,btts:0};
    const gH=+r.FTHG||0, gA=+r.FTAG||0, tot=gH+gA;
    byDivSeason[div][sk].n++; if((r.FTR||'').toUpperCase()==='H') byDivSeason[div][sk].homeWins++;
    if(tot>=3) byDivSeason[div][sk].over25++; if(gH>0&&gA>0) byDivSeason[div][sk].btts++;
    glob.n++; glob.homeWins += ((r.FTR||'').toUpperCase()==='H')?1:0; if(tot>=3) glob.over25++; if(gH>0&&gA>0) glob.btts++;
  }
  const pGlob = {home: (glob.homeWins/Math.max(1,glob.n)), over: (glob.over25/Math.max(1,glob.n)), btts:(glob.btts/Math.max(1,glob.n))};
  for(const div in byDivSeason){
    const seasons = Object.keys(byDivSeason[div]).sort((a,b)=>{
      const parseSeason = (s)=>{
        if(!s) return 0;
        if(s.includes('/')){
          const parts=s.split('/');
          return parseInt(parts[1],10) || parseInt(parts[0],10) || 0;
        }
        return parseInt(s,10) || 0;
      };
      return parseSeason(b) - parseSeason(a);
    });
    let nUse = overrides[div] || (TIER_TOP5.has(div)?nTop5:(TIER_SECOND.has(div)?nSeg:nMed));
    nUse = Math.max(1, Math.min(nUse, seasons.length));
    let N=0, H=0, O=0, B=0;
    const used=[], weights=[];
    for(let i=0;i<nUse;i++){
      const sKey=seasons[i];
      const w = decayWeight(i, preset);
      const st=byDivSeason[div][sKey];
      used.push(sKey); weights.push(w.toFixed(2));
      N += w * st.n; H += w * st.homeWins; O += w * st.over25; B += w * st.btts;
    }
    const n = Math.max(1, N);
    const pH = (H + alpha*pGlob.home) / (n + alpha);
    const pO = (O + alpha*pGlob.over) / (n + alpha);
    const pB = (B + alpha*pGlob.btts) / (n + alpha);
    out[div] = { homeBias:(pH-0.45), overBias:(pO-0.50), bttsBias:(pB-0.50), usedSeasons:used, weights:weights, totalRows:Math.round(N), preset, bayesAlpha:alpha };
  }
  return out;
}

function computeTeamStats(histRows){
  const stats = {};
  if (!histRows || !histRows.length) return stats;

  const rows = histRows.slice().sort((a,b)=>{
    const da = parseHistDate(a); const db = parseHistDate(b);
    const ta = da ? da.getTime() : 0;
    const tb = db ? db.getTime() : 0;
    return ta - tb;
  });

  for (const r of rows){
    const div = r.Div; if (!div) continue;
    const home = r.HomeTeam, away = r.AwayTeam;
    if (!home || !away) continue;
    const d = parseHistDate(r); if (!d) continue;
    const ts = d.getTime();
    const gH = +r.FTHG || 0;
    const gA = +r.FTAG || 0;
    const ftr = (r.FTR||'').toUpperCase();

    const resHome = (ftr==='H') ? 'W' : (ftr==='D'?'D':(ftr==='A'?'L':null));
    const resAway = (ftr==='A') ? 'W' : (ftr==='D'?'D':(ftr==='H'?'L':null));

    const kHome = div+'::'+home;
    const kAway = div+'::'+away;

    if (resHome){
      if (!stats[kHome]) stats[kHome]={home:[],away:[]};
      stats[kHome].home.push({ts, r:resHome, gf:gH, ga:gA, cf:(r.HC!=null?Number(r.HC):null), ca:(r.AC!=null?Number(r.AC):null)});
    }
    if (resAway){
      if (!stats[kAway]) stats[kAway]={home:[],away:[]};
      stats[kAway].away.push({ts, r:resAway, gf:gA, ga:gH, cf:(r.AC!=null?Number(r.AC):null), ca:(r.HC!=null?Number(r.HC):null)});
    }
  }
  return stats;
}

function recentRecord(div, team, side, limit){
  const key = div+'::'+team;
  const s = TEAM_STATS[key];
  if (!s) return null;
  const arr = side==='away' ? (s.away||[]) : (s.home||[]);
  if (!arr.length) return null;
  const lim = limit || 10;
  const slice = arr.slice(Math.max(0, arr.length - lim));
  let w=0,d=0,l=0, gf=0, ga=0, cf=0, ca=0, cn=0;
  slice.forEach(m=>{
    if (m.r==='W') w++; else if (m.r==='D') d++; else l++;
    gf += m.gf||0;
    ga += m.ga||0;
    if(m.cf!=null && isFinite(m.cf) && m.ca!=null && isFinite(m.ca)){ cf += m.cf; ca += m.ca; cn += 1; };
  });
  const n = slice.length;
  return {n,w,d,l,gf,ga, cf:(cn?cf/cn:null), ca:(cn?ca/cn:null), cn};
}


function sentenceRecord(div, team, side, limit){
  const rec = recentRecord(div, team, side, limit);
  if (!rec) return '';
  const where = side==='away' ? 'fora de casa' : 'em casa';
  const {n,w,d,l,gf,ga} = rec;
  const avgGF = (gf/n).toFixed(2);
  const avgGA = (ga/n).toFixed(2);
  let base = `Nos últimos ${n} jogos ${where}, o ${team}`;
  if (l === 0){
    base += ` não perdeu: ${w} vitórias e ${d} empates, com ${gf} golos marcados (${avgGF}/jogo) e ${ga} sofridos (${avgGA}/jogo).`;
  } else {
    base += ` somou ${w} vitórias, ${d} empates e ${l} derrotas, marcando ${gf} golos (${avgGF}/jogo) e sofrendo ${ga} (${avgGA}/jogo).`;
  }
  return base;
}

function formScore(div, team, side, limit){
  const rec = recentRecord(div, team, side, limit || 8);
  if (!rec) return 0;
  const {n,w,d,l,gf,ga} = rec;
  if (!n) return 0;

  const pts = w*3 + d;
  const ptsPerGame = pts / n;
  const gdPerGame  = (gf - ga) / n;

  const normPts = ptsPerGame / 3;
  const normGD  = 0.5 + (gdPerGame / 4);
  const rating  = 0.6*normPts + 0.4*Math.max(0, Math.min(1, normGD));

  return Math.max(0, Math.min(1, rating));
}
function leagueTableSnapshot(div, upToTs){
  if (!TEAM_STATS) return null;
  const seasonKey = seasonKeyFromDate(new Date(upToTs), div);
  if (!seasonKey) return null;
  const rows = [];
  for (const key in TEAM_STATS){
    const parts = key.split('::');
    if (parts.length !== 2) continue;
    const d = parts[0], team = parts[1];
    if (d !== div) continue;
    const s = TEAM_STATS[key];
    let played=0, w=0, dr=0, l=0, gf=0, ga=0;
    const acc = (arr)=>{
      (arr||[]).forEach(m=>{
        const dt = new Date(m.ts||0);
        if (seasonKeyFromDate(dt, div) !== seasonKey) return;
        if (m.ts > upToTs) return;
        played++;
        if (m.r==='W') w++; else if (m.r==='D') dr++; else l++;
        gf += m.gf||0;
        ga += m.ga||0;
      });
    };
    acc(s.home);
    acc(s.away);
    if (played>0){
      const pts = w*3 + dr;
      rows.push({team,played,w,dr,l,gf,ga,gd:gf-ga,pts});
    }
  }
  if (!rows.length) return null;
  rows.sort((a,b)=>{
    if (b.pts!==a.pts) return b.pts-a.pts;
    if (b.gd!==a.gd) return b.gd-a.gd;
    if (b.gf!==a.gf) return b.gf-a.gf;
    return a.team.localeCompare(b.team);
  });
  rows.forEach((r,i)=>{ r.pos = i+1; });
  let matchDay = 0;
  rows.forEach(r=>{ if (r.played>matchDay) matchDay = r.played; });
  return {season:seasonKey, rows, matchDay};
}

function lastResultsAll(div, team, upToTs, limit){
  const key = div+'::'+team;
  const s = TEAM_STATS[key];
  if (!s) return [];
  const seasonNow = seasonKeyFromDate(new Date(upToTs), div);
  const arr = [];

  function collect(list){
    (list||[]).forEach(m=>{
      const dt = new Date(m.ts||0);
      if (seasonKeyFromDate(dt, div) !== seasonNow) return;
      if (m.ts > upToTs) return;
      arr.push({ts:m.ts, r:m.r});
    });
  }

  collect(s.home);
  collect(s.away);
  if (!arr.length) return [];

  arr.sort((a,b)=>b.ts - a.ts);
  const slice = arr.slice(0, limit||5);
  return slice.map(x=>x.r); // 'W','D','L'
}

function buildStandingsHTML(div, upToTs, homeTeam, awayTeam){
  const snap = leagueTableSnapshot(div, upToTs);
  if (!snap) return '';

  let html = '<div class="standings-block">';
  html += '<div class="standings-title">Classificação</div>';
  if (snap.matchDay){
    html += '<div class="standings-sub">Jornada '+(snap.matchDay+1)+' · antes deste jogo</div>';
  } else {
    html += '<div class="standings-sub">Tabela actual antes deste jogo</div>';
  }

  html += '<table class="standings-table">';
  html += '<thead><tr>'+
          '<th>#</th>'+
          '<th>Equipa</th>'+
          '<th>PJ</th>'+
          '<th>V</th>'+
          '<th>E</th>'+
          '<th>D</th>'+
          '<th>G</th>'+
'<th>P</th>'+
          '<th>Forma</th>'+
          '</tr></thead><tbody>';

  snap.rows.forEach(r=>{
    const isHighlight = (r.team === homeTeam || r.team === awayTeam);
    html += '<tr'+(isHighlight?' class="standings-highlight"':'')+'>';
    html += '<td>'+r.pos+'</td>';
    html += '<td>'+r.team+'</td>';
    html += '<td>'+r.played+'</td>';
    html += '<td>'+r.w+'</td>';
    html += '<td>'+r.dr+'</td>';
    html += '<td>'+r.l+'</td>';
    html += '<td>'+r.gf+':'+r.ga+'</td>';
html += '<td>'+r.pts+'</td>';

    const form = lastResultsAll(div, r.team, upToTs, 5);
    html += '<td><div class="standings-form">';
    form.forEach(code=>{
      let cls = 'form-L', lbl='D';
      if (code === 'W'){ cls='form-W'; lbl='V'; }
      else if (code === 'D'){ cls='form-D'; lbl='E'; }
      html += '<span class="form-badge '+cls+'">'+lbl+'</span>';
    });
    html += '</div></td>';

    html += '</tr>';
  });

  html += '</tbody></table></div>';
  return html;
}


function teamTableEntry(div, team, upToTs){
  const snap = leagueTableSnapshot(div, upToTs);
  if (!snap) return null;
  return snap.rows.find(r=>r.team===team) || null;
}

function ordinalPt(n){
  return `${n}.º`;
}

function sentenceTable(div, team, upToTs){
  const e = teamTableEntry(div, team, upToTs);
  if (!e) return '';
  const {pos, pts, played, w, dr, l, gf, ga} = e;
  return `O ${team} chega a esta jornada na ${ordinalPt(pos)} posição, com ${pts} pontos em ${played} jogos (${w} vitórias, ${dr} empates e ${l} derrotas, golos ${gf}-${ga}).`;
}

function sentenceMotivation(div, team, upToTs){
  const snap = leagueTableSnapshot(div, upToTs);
  if (!snap) return '';
  const e = snap.rows.find(r=>r.team===team);
  if (!e) return '';
  const nTeams = snap.rows.length;
  const matchDay = snap.matchDay || e.played;
  const maxMatchDays = Math.max(1, (nTeams-1)*2);
  const phase = matchDay / maxMatchDays;
  if (phase < 0.55) return '';
  let msg = '';
  if (e.pos === 1){
    msg = `${team} está na luta directa pelo título e entra pressionado a somar pontos para segurar a liderança.`;
  } else if (e.pos <= 3){
    msg = `${team} está em zona de topo da tabela e claramente envolvido na corrida pelo título e lugares europeus.`;
  } else if (e.pos <= 6){
    msg = `${team} discute o acesso às competições europeias e cada ponto nesta fase pode ser decisivo.`;
  } else if (e.pos >= nTeams-2){
    msg = `${team} está mergulhado na luta pela permanência e sente grande pressão para fugir da zona de descida.`;
  } else if (e.pos >= nTeams-4){
    msg = `${team} está muito próximo da zona de descida e necessita de pontos para ganhar margem de segurança.`;
  } else {
    msg = `${team} ocupa uma posição intermédia, com alguma margem em relação à descida mas ainda distante do topo da classificação.`;
  }
  return msg;
}




function motivationChips(div, home, away, ts){
  const snap = leagueTableSnapshot(div, ts);
  if (!snap) return '';
  const nTeams = snap.rows.length || 0;
  const eH = teamTableEntry(div, home, ts);
  const eA = teamTableEntry(div, away, ts);
  const motH = motivationScore(div, home, ts);
  const motA = motivationScore(div, away, ts);

  const chips = [];
  if (motH > 0.7 || motA > 0.7)
    chips.push('<span class="mot-chip mot-hot">🔥 alta motivação</span>');

  const isReleg = (e)=> e && nTeams>=4 && e.pos >= nTeams-1;
  if (isReleg(eH) || isReleg(eA))
    chips.push('<span class="mot-chip mot-danger">🆘 permanência</span>');

  return chips.join('');
}

function motivationScore(div, team, upToTs){

  const snap = leagueTableSnapshot(div, upToTs);
  if (!snap) return 0;
  const e = snap.rows.find(r=>r.team===team);
  if (!e) return 0;
  const nTeams = snap.rows.length;
  const matchDay = snap.matchDay || e.played;
  const maxMatchDays = Math.max(1, (nTeams-1)*2);
  const phase = matchDay / maxMatchDays;
  if (phase < 0.55) return 0;

  const pos = e.pos;
  const ratio = (pos-1)/Math.max(1,(nTeams-1));
  let score = 0;

  // Zona de topo / título / Europa
  if (pos === 1){
    score = 1.0;
  } else if (pos <= 3){
    score = 0.8;
  } else if (pos <= 6){
    score = 0.6;
  }
  // Fundo da tabela / luta pela permanência
  else if (ratio > 0.9){
    score = 0.9;
  } else if (ratio > 0.75){
    score = 0.7;
  } else {
    // Meia tabela: em fase final da época pode haver menos urgência
    if (phase >= 0.75){
      score = -0.3;
    } else {
      score = 0.0;
    }
  }
  return score;
}




const EURO_SPOTS = {
  'E0': 7,   // Premier League
  'SP1': 7,  // La Liga
  'D1': 6,   // Bundesliga
  'I1': 7,   // Serie A
  'F1': 6,   // Ligue 1
  'P1': 6,   // Primeira Liga
  'NL1': 5,  // Eredivisie
  'B1': 5,   // Jupiler Pro League
  'G1': 5,   // Super League Greece
  'T1': 5    // Süper Lig
};

function previousSeasonKeyFromSeason(seasonKey){
  if (!seasonKey) return null;
  const parts = seasonKey.split('/');
  if (parts.length !== 2) return null;
  const y1 = parseInt(parts[0],10);
  const y2 = parseInt(parts[1],10);
  if (!y1 || !y2) return null;
  return (y1-1) + '/' + y1;
}

function leagueTableSnapshotSeason(div, seasonKey){
  if (!TEAM_STATS || !seasonKey) return null;
  const rows = [];
  for (const key in TEAM_STATS){
    const parts = key.split('::');
    if (parts.length !== 2) continue;
    const d = parts[0], team = parts[1];
    if (d !== div) continue;
    const s = TEAM_STATS[key];
    let played=0, w=0, dr=0, l=0, gf=0, ga=0;
    const acc = (arr)=>{
      (arr||[]).forEach(m=>{
        const dt = new Date(m.ts||0);
        if (seasonKeyFromDate(dt, div) !== seasonKey) return;
        played++;
        if (m.r==='W') w++; else if (m.r==='D') dr++; else l++;
        gf += m.gf||0;
        ga += m.ga||0;
      });
    };
    acc(s.home);
    acc(s.away);
    if (played>0){
      const pts = w*3 + dr;
      rows.push({team,played,w,dr,l,gf,ga,gd:gf-ga,pts});
    }
  }
  if (!rows.length) return null;
  rows.sort((a,b)=>{
    if (b.pts!==a.pts) return b.pts-a.pts;
    if (b.gd!==a.gd) return b.gd-a.gd;
    if (b.gf!==a.gf) return b.gf-a.gf;
    return a.team.localeCompare(b.team);
  });
  rows.forEach((r,i)=>{ r.pos = i+1; });
  return {season:seasonKey, rows};
}

function lastSeasonEntry(div, team, upToTs){
  const seasonNow = seasonKeyFromDate(new Date(upToTs), div);
  if (!seasonNow) return null;
  const prev = previousSeasonKeyFromSeason(seasonNow);
  if (!prev) return null;
  const snap = leagueTableSnapshotSeason(div, prev);
  if (!snap) return null;
  return snap.rows.find(r=>r.team===team) || null;
}

function hasEuropeanLoad(div, entry){
  if (!entry) return false;
  const max = EURO_SPOTS[div];
  if (!max) return false;
  if (!entry.pos) return false;
  return entry.pos <= max;
}

function europeMeta(div, home, away, ts){
  const eH = lastSeasonEntry(div, home, ts);
  const eA = lastSeasonEntry(div, away, ts);
  const homeEU = hasEuropeanLoad(div, eH);
  const awayEU = hasEuropeanLoad(div, eA);
  return {
    homeEU,
    awayEU,
    posHome: eH ? eH.pos : null,
    posAway: eA ? eA.pos : null
  };
}

function isEuropeHeavy1X2(div, home, away, pickSide, ts){
  const {homeEU, awayEU, posHome, posAway} = europeMeta(div, home, away, ts);
  if (pickSide === '1' && homeEU){
    if (!awayEU || (posHome && posAway && posAway > posHome + 2)) return true;
  }
  if (pickSide === '2' && awayEU){
    if (!homeEU || (posHome && posAway && posHome > posAway + 2)) return true;
  }
  return false;
}

function headToHead(div, home, away, upToTs, limit){
  if (!HIST_ALL || !HIST_ALL.length) return null;
  const lim = limit || 5;
  const matches = [];
  for (const r of HIST_ALL){
    if (r.Div !== div) continue;
    const h = r.HomeTeam, a = r.AwayTeam;
    if (!h || !a) continue;
    if (!((h===home && a===away) || (h===away && a===home))) continue;
    const d = parseHistDate(r); if (!d) continue;
    const ts = d.getTime();
    if (upToTs && ts > upToTs) continue;
    const ftr = (r.FTR||'').toUpperCase();
    const gH = +r.FTHG||0, gA = +r.FTAG||0;
    matches.push({ts, home:h, away:a, ftr, gH, gA});
  }
  if (!matches.length) return null;
  matches.sort((a,b)=>a.ts-b.ts);
  const slice = matches.slice(Math.max(0, matches.length-lim));
  let wHome=0,d=0,wAway=0,gfHome=0,gfAway=0;
  slice.forEach(m=>{
    let gHomePers, gAwayPers, resPers;
    if (m.home===home && m.away===away){
      gHomePers = m.gH; gAwayPers = m.gA;
      if (m.ftr==='H') resPers='W'; else if(m.ftr==='D') resPers='D'; else if(m.ftr==='A') resPers='L';
    } else {
      gHomePers = m.gA; gAwayPers = m.gH;
      if (m.ftr==='A') resPers='W'; else if(m.ftr==='D') resPers='D'; else if(m.ftr==='H') resPers='L';
    }
    gfHome += gHomePers;
    gfAway += gAwayPers;
    if (resPers==='W') wHome++;
    else if (resPers==='D') d++;
    else wAway++;
  });
  const n = slice.length;
  return {n,wHome,d,wAway,gfHome,gfAway};
}

function sentenceH2H(div, home, away, upToTs, limit){
  const h = headToHead(div, home, away, upToTs, limit);
  if (!h || !h.n) return '';
  const {n,wHome,d,wAway,gfHome,gfAway} = h;
  return `Nos últimos ${n} confrontos directos entre ${home} e ${away}, o ${home} ganhou ${wHome} vezes, o ${away} venceu ${wAway} e registaram-se ${d} empates (golos ${home} ${gfHome} – ${gfAway} ${away}).`;
}


function lastMatchesTeam(div, team, upToTs, limit){
  if(!HIST_ALL || !HIST_ALL.length) return [];
  const lim = limit || 5;
  const rows = [];
  for(const r of HIST_ALL){
    if(r.Div !== div) continue;
    const h = r.HomeTeam, a = r.AwayTeam;
    if(!h || !a) continue;
    if(h!==team && a!==team) continue;
    const d = parseHistDate(r); if(!d) continue;
    const ts = d.getTime();
    if(upToTs && ts >= upToTs) continue;
    const ftr = (r.FTR||'').toUpperCase();
    let gf=0, ga=0, res='', opp='', loc='';
        if(h===team){
      // Quando a equipa analisada joga em casa, mantemos formato normal casa-fora
      gf = +r.FTHG||0;
      ga = +r.FTAG||0;
      opp = a;
      loc = 'casa';
      if(ftr==='H') res='V'; else if(ftr==='D') res='E'; else if(ftr==='A') res='D';
    }else{
      // Quando a equipa analisada joga fora, queremos ver o resultado em formato "casa-fora"
      // Ex.: derrota 3-2 fora aparece como "3-2" (não "2-3")
      gf = +r.FTHG||0;
      ga = +r.FTAG||0;
      opp = h;
      loc = 'fora';
      if(ftr==='A') res='V'; else if(ftr==='D') res='E'; else if(ftr==='H') res='D';
    }

    const dd = String(d.getDate()).padStart(2,'0');
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const yy = String(d.getFullYear()).slice(-2);
    const dateStr = `${dd}.${mm}.${yy}`;
    const score = `${gf}-${ga}`;
    rows.push({ts,date:dateStr,opp,loc,score,res,home:h,away:a});
  }
  if(!rows.length) return [];
  rows.sort((a,b)=>b.ts-a.ts);
  return rows.slice(0, lim);
}

function lastMatchesH2H(div, home, away, upToTs, limit){
  if(!HIST_ALL || !HIST_ALL.length) return [];
  const lim = limit || 5;
  const rows = [];
  for(const r of HIST_ALL){
    if(r.Div !== div) continue;
    const h = r.HomeTeam, a = r.AwayTeam;
    if(!h || !a) continue;
    if(!((h===home && a===away) || (h===away && a===home))) continue;
    const d = parseHistDate(r); if(!d) continue;
    const ts = d.getTime();
    if(upToTs && ts >= upToTs) continue;
    const ftr = (r.FTR||'').toUpperCase();
    const gH = +r.FTHG||0, gA = +r.FTAG||0;
    const dd = String(d.getDate()).padStart(2,'0');
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const yy = String(d.getFullYear()).slice(-2);
    const dateStr = `${dd}.${mm}.${yy}`;
    let resTag='';
    if(ftr==='H') resTag=h===home?'V':'D';
    else if(ftr==='A') resTag=a===home?'D':'V';
    else if(ftr==='D') resTag='E';
    rows.push({ts,date:dateStr,home:h,away:a,score:`${gH}-${gA}`,res:resTag});
  }
  if(!rows.length) return [];
  rows.sort((a,b)=>b.ts-a.ts);
  return rows.slice(0, lim);
}

function buildStatsPanel(matchRow, homeName, awayName){
  if(!matchRow) return '<div class="mini-stats-panel">Sem estatísticas detalhadas para este jogo.</div>';

    const metrics = [
    {keyH:'FTHG', keyA:'FTAG', label:'Golos (total)'},
    {keyH:'HTHG', keyA:'HTAG', label:'Golos ao intervalo'},
    {keyH:'HS',   keyA:'AS',   label:'Remates'},
    {keyH:'HST',  keyA:'AST',  label:'Remates enquadrados'},
    {keyH:'HC',   keyA:'AC',   label:'Cantos'},
    {keyH:'HF',   keyA:'AF',   label:'Faltas cometidas'},
    {keyH:'HY',   keyA:'AY',   label:'Cartões amarelos'},
    {keyH:'HR',   keyA:'AR',   label:'Cartões vermelhos'}
  ];


let html = '<div class="mini-stats-panel">'+
           '<div class="mini-stats-header">'+
             '<strong>Estatísticas do jogo</strong>'+
             
           '</div>'+
           '<div class="mini-stats-match">'+homeName+' vs '+awayName+'</div><br>';



  for(const m of metrics){
    const vH = Number(matchRow[m.keyH] || 0);
    const vA = Number(matchRow[m.keyA] || 0);
    if(!(vH || vA)) continue;
    const total = vH + vA || 1;
    const pctH = Math.round(vH/total*100);
    const pctA = 100 - pctH;

    html += '<div class="mini-stat-row">';
    html +=   '<div class="mini-stat-label">'+m.label+'</div>';
    html +=   '<div class="mini-stat-bars">';
    html +=     '<div class="mini-stat-bar-home" style="width:'+pctH+'%"></div>';
    html +=     '<div class="mini-stat-bar-away" style="width:'+pctA+'%"></div>';
    html +=   '</div>';
    html +=   '<div class="mini-stat-values">'+vH+' - '+vA+'</div>';
    html += '</div>';
  }

  html += '</div>';
  return html;
}
function h2hScore(div, home, away, upToTs, limit){
  const h = headToHead(div, home, away, upToTs, limit);
  if (!h || !h.n) return 0;
  const {n,wHome,d,wAway,gfHome,gfAway} = h;
  const ptsHome = wHome*3 + d;
  const ptsAway = wAway*3 + d;
  const maxPts = 3*n || 1;

  const ratingPts = (ptsHome - ptsAway) / maxPts;
  const gdPerGame = (gfHome - gfAway) / Math.max(1,n);
  const ratingGD  = gdPerGame / 3;

  let score = 0.7*ratingPts + 0.3*ratingGD;
  if (score > 1) score = 1;
  if (score < -1) score = -1;
  return score;
}

function applyFLB(prob, odd){
  if(!document.getElementById('corrFLB').checked) return prob;
  if(odd>=4.0) return clamp01(prob*1.05);
  if(odd<=1.50) return clamp01(prob*0.97);
  return prob;
}

function dampProb(prob, odd){
  // Ajuste conservador + Favourite-Longshot Bias (FLB) leve.
  // Objetivo: reduzir overconfidence e tornar odds estimadas mais realistas.
  let p = clamp01(prob);

  // compressão suave em torno de 0.5 (menos agressiva que versões antigas, mas consistente)
  const edge = Math.abs(p - 0.5) * 2; // 0..1
  const oddNum = (odd && isFinite(odd)) ? Number(odd) : 2.0;

  // mais compressão em extremos de odd (favorito muito baixo ou outsider alto)
  const edgeOdd = (oddNum <= 1.45 || oddNum >= 4.0) ? 0.28 : 0.18;
  p = 0.5 + (p - 0.5) * (1 - edgeOdd);

  // FLB: favoritos tendem a estar ligeiramente sobrevalorizados pelo mercado, outsiders subavaliados.
  // Aqui aplicamos uma correção mínima no sentido de "piorar" um pouco o p para odds muito baixas
  // e "melhorar" um pouco o p para odds altas, evitando exageros.
  if (oddNum <= 1.60){
    p *= (1 - 0.018*edge);
  } else if (oddNum >= 3.20){
    p *= (1 + 0.012*edge);
  }

  // corta p acima de 0.86 de forma não-linear (evita 90%+ sem edge gigantesco)
  if (p > 0.86){
    p = 0.86 + (p - 0.86) * 0.35;
  }

  return clamp01(p);
}



function buildMarkets(row, calib){
  // =========================
  // LuxTIPS Market Engine V2
  // Objetivo: gerar uma grelha alargada de mercados (tipo sportsbook)
  // mantendo foco em estabilidade (probabilidade) e controlo de overconfidence.
  // =========================

  const base = implied1x2(row) || {H:0.45,D:0.25,A:0.30,src:'default',odds:{H:2.2,D:3.3,A:3.4}};
  const c = calib[row.Div] || {homeBias:0,overBias:0,bttsBias:0,usedSeasons:[],weights:[],totalRows:0};

  const div  = String(row.Div||'').toUpperCase();
  const home = row.HomeTeam || row.Home || '';
  const away = row.AwayTeam || row.Away || '';
  const ts   = tsFromRow(row);

  // ---- helpers matemáticos (Poisson) ----
  function fact(n){ let f=1; for(let i=2;i<=n;i++) f*=i; return f; }
  function poisP(k, lam){
    if(lam<=0) return (k===0?1:0);
    // estável o suficiente para k<=10 (limites abaixo)
    return Math.exp(-lam) * Math.pow(lam, k) / fact(k);
  }
  function poisCDF(k, lam){
    let s=0;
    for(let i=0;i<=k;i++) s += poisP(i, lam);
    return clamp01(s);
  }


  // ---- Dixon–Coles (ajuste de low-scores) ----
  function dcTau(x,y,lamH,lamA,rho){
    // Apenas ajusta 0-0, 0-1, 1-0, 1-1
    if(x===0 && y===0) return 1 - (lamH*lamA*rho);
    if(x===0 && y===1) return 1 + (lamH*rho);
    if(x===1 && y===0) return 1 + (lamA*rho);
    if(x===1 && y===1) return 1 - rho;
    return 1;
  }
  function dc1x2Probs(lamH, lamA, rho){
    const maxG = 8;
    let pH=0,pD=0,pA=0, sum=0;
    for(let i=0;i<=maxG;i++){
      const pi = poisP(i, lamH);
      for(let j=0;j<=maxG;j++){
        const pj = poisP(j, lamA);
        let p = pi*pj*dcTau(i,j,lamH,lamA,rho);
        if(!isFinite(p) || p<0) p=0;
        sum += p;
        if(i>j) pH += p;
        else if(i===j) pD += p;
        else pA += p;
      }
    }
    if(sum<=0) return {H:0.45,D:0.25,A:0.30};
    pH/=sum; pD/=sum; pA/=sum;
    return {H:clamp01(pH), D:clamp01(pD), A:clamp01(pA)};
  }

  // ---- Calibração sigmoid por família ----
  const CALIB_FAM = {
    'RESULTADO': {a: 0.00, b: 0.85},
    'TOTAL':     {a: 0.00, b: 0.88},
    'BTTS':      {a: 0.00, b: 0.82},
    'AH':        {a: 0.00, b: 0.86},
    'CORNERS':   {a: 0.00, b: 0.78}
  };
  function logit(p){ p=clamp01(p); return Math.log(p/(1-p)); }
  function sigmoid(z){ return 1/(1+Math.exp(-z)); }
  function calibSigmoid(fam, p, dataStrength){
    const c = CALIB_FAM[fam] || {a:0,b:0.86};
    const ds = clamp01(dataStrength==null?0.6:dataStrength);
    const b = c.b * (0.80 + 0.20*ds);
    const z = c.a + b*logit(p);
    return clamp01(sigmoid(z));
  }

  // ---- Market alignment dinâmico (quando há odd real) ----
  function impliedProbSingle(odd, vig){
    const o = (odd && isFinite(odd) && odd > 1.01) ? Number(odd) : null;
    if(!o) return null;
    const p = 1 / o;
    const adj = (1 + (vig ?? 0.06));
    return clamp01(p / adj);
  }
  function marketVigByFam(fam){
    if(fam==='RESULTADO') return 0.065;
    if(fam==='TOTAL') return 0.055;
    if(fam==='BTTS') return 0.060;
    if(fam==='AH') return 0.055;
    if(fam==='CORNERS') return 0.070;
    return 0.060;
  }
  function modelWeightByFam(fam, dataStrength){
    const ds = clamp01(dataStrength==null?0.6:dataStrength);
    let base = 0.72;
    if(fam==='RESULTADO') base = 0.70;
    if(fam==='TOTAL') base = 0.72;
    if(fam==='AH') base = 0.70;
    if(fam==='BTTS') base = 0.66;
    if(fam==='CORNERS') base = 0.60;
    return clamp( base + 0.18*(ds-0.5), 0.52, 0.86);
  }
  function alignToMarket(pModel, oddReal, fam, dataStrength){
    const pMkt = impliedProbSingle(oddReal, marketVigByFam(fam));
    if(!(pMkt>0)) return clamp01(pModel);
    const wModel = modelWeightByFam(fam, dataStrength);
    return blendProb(clamp01(pModel), clamp01(pMkt), wModel);
  }

  // ---- Modelo Poisson separado para cantos ----
  function cornersLambda(recH, recA){
    const H_cf = (recH && recH.cf!=null)? recH.cf : null;
    const H_ca = (recH && recH.ca!=null)? recH.ca : null;
    const A_cf = (recA && recA.cf!=null)? recA.cf : null;
    const A_ca = (recA && recA.ca!=null)? recA.ca : null;

    const baseH = 5.3, baseA = 4.7;
    const n = Math.min((recH&&recH.cn)||0, (recA&&recA.cn)||0);
    const ds = clamp01(n/8);

    const hf = (H_cf!=null?H_cf:baseH), ha=(H_ca!=null?H_ca:baseA);
    const af = (A_cf!=null?A_cf:baseA), aa=(A_ca!=null?A_ca:baseH);

    let lamH = (hf + aa)/2;
    let lamA = (af + ha)/2;

    lamH = ds*lamH + (1-ds)*baseH;
    lamA = ds*lamA + (1-ds)*baseA;

    lamH = clamp(lamH, 2.5, 8.5);
    lamA = clamp(lamA, 2.0, 8.0);

    return {lamH, lamA, lamT: lamH+lamA, ds};
  }


function totalProbOver(line, lamT){
    // P(G > line). line em .5 -> floor(line)
    const k = Math.floor(line);
    return clamp01(1 - poisCDF(k, lamT));
  }
  function totalProbUnder(line, lamT){
    const k = Math.floor(line);
    return clamp01(poisCDF(k, lamT));
  }

  // ---- forma, H2H, motivação, desgaste (já existe no ficheiro) ----
  const fH = formScore(div, home, 'home', 8);
  const fA = formScore(div, away, 'away', 8);
  const formDelta = clamp(fH - fA, -0.8, 0.8);

  const h2h = h2hScore(div, home, away, ts, 8); // [-1..1] pró-casa
  const motH = motivationScore(div, home, ts);
  const motA = motivationScore(div, away, ts);

  // ---- estimativa de intensidades de golo (λ) ----
  // Total de golos esperado: combina:
  // - "eg" (proxy baseado em GF/GA recentes)
  // - bias de liga para OVER
  // - equilíbrio (jogos equilibrados tendem a ter mais golos em média em algumas ligas)
  const recH = recentRecord(div, home, 'home', 10);
  const recA = recentRecord(div, away, 'away', 10);

  const H_gf = (recH && recH.n) ? (recH.gf/Math.max(1,recH.n)) : 1.15;
  const H_ga = (recH && recH.n) ? (recH.ga/Math.max(1,recH.n)) : 1.10;
  const A_gf = (recA && recA.n) ? (recA.gf/Math.max(1,recA.n)) : 1.05;
  const A_ga = (recA && recA.n) ? (recA.ga/Math.max(1,recA.n)) : 1.15;

  const eg = clamp01((H_gf + A_gf + H_ga + A_ga)/6); // ~0.40..0.60 típico

  const balance = 1 - Math.abs(base.H - base.A);     // 0..1
  const egCenter = 0.52;
  const egDelta  = clamp(eg - egCenter, -0.25, 0.25);

  // λ_total na escala 1.9..3.2 (suficiente para linhas comuns)
  let lamT = 2.55
    + 1.15*egDelta
    + 0.65*c.overBias
    + 0.12*(balance-0.5);

  // motivação (mais urgência -> mais risco -> mais eventos)
  lamT *= (1 + 0.06*(motH+motA));

  // forma extrema tende a aumentar eficiência (ligeiro)
  lamT *= (1 + 0.05*Math.abs(formDelta));

  lamT = clamp(lamT, 1.80, 3.60);

  // Split home/away via força do 1X2 + bias casa
  // usar logit no ratio para não explodir
  const strength = clamp((base.H - base.A) + c.homeBias*0.8 + 0.18*formDelta + 0.10*h2h + 0.10*(motH-motA), -0.65, 0.65);
  const shareH = clamp01(0.50 + 0.48*strength);  // 0.19..0.81
  let lamH = lamT * shareH;
  let lamA = lamT - lamH;

  lamH = clamp(lamH, 0.35, 2.95);
  lamA = clamp(lamA, 0.35, 2.95);

  // ---- derivar probabilidades chave ----
  // 1X2: Poisson + Dixon–Coles (low-score) + shrinkage (λH/λA)
  const dataStrength = clamp01(Math.min((recH&&recH.n)||0, (recA&&recA.n)||0) / 10);

  // Shrink λ para médias de liga (estabiliza com poucos jogos)
  const baseLamH = 1.30, baseLamA = 1.15; // leve HA
  lamH = dataStrength*lamH + (1-dataStrength)*baseLamH;
  lamA = dataStrength*lamA + (1-dataStrength)*baseLamA;
  lamH = clamp(lamH, 0.35, 2.95);
  lamA = clamp(lamA, 0.35, 2.95);
  lamT = lamH + lamA;

  // rho Dixon–Coles: mais negativo em jogos equilibrados (mais draw/low-score)
  const bal = clamp01(1 - Math.abs(base.H - base.A)); // usa strength inicial só para equilíbrio
  const rho = clamp(-0.12*bal, -0.14, 0.0);

  const dc = dc1x2Probs(lamH, lamA, rho);

  // Probabilidades base do modelo (antes de contexto)
  let Hm = dc.H + c.homeBias*0.5;
  let Am = dc.A - c.homeBias*0.5;
  let Dm = dc.D;

  // forma/motivação
  const Kmot = 0.06, Kform = 0.05, Kh2h = 0.035;
  Hm *= (1 + Kmot*motH) * (1 + Kform*formDelta) * (1 + Kh2h*h2h);
  Am *= (1 + Kmot*motA) * (1 - Kform*formDelta) * (1 - Kh2h*h2h);

  // evitar draw demasiado alto quando lamT é alto
  const drawDamp = clamp(0.06 + (lamT-2.55)*0.07, -0.10, 0.18);
  Dm = clamp01(Dm * (1 - drawDamp));

  Hm=clamp01(Hm); Am=clamp01(Am); Dm=clamp01(Dm);
  const s = Hm+Am+Dm || 1; Hm/=s; Am/=s; Dm/=s;

  // FLB no 1X2
  Hm = applyFLB(Hm, base.odds.H);
  Am = applyFLB(Am, base.odds.A);
  const nFlb = Hm+Am+Dm || 1; Hm/=nFlb; Am/=nFlb; Dm/=nFlb;

  // BTTS via 1 - P(H=0) - P(A=0) + P(H=0,A=0)
  // com ajuste de liga + eg
  const pH0 = poisP(0, lamH);
  const pA0 = poisP(0, lamA);
  let PBTTS = clamp01(1 - pH0 - pA0 + (pH0*pA0));
  PBTTS = clamp01(PBTTS + 0.55*c.bttsBias + 0.20*egDelta);

  // Over2.5 a partir de Poisson total (ajustado por liga)
  let Pover25 = totalProbOver(2.5, lamT);
  Pover25 = clamp01(Pover25 + 0.55*c.overBias);

  const favH = Hm>=Am;
  const pFav = favH ? Hm : Am;
  const favTeam = favH ? home : away;
  const dogTeam = favH ? away : home;

  // Asian lines (aprox) por força do favorito + λ_total
  function ahCoverProb(line){
    // line negativo favorece favorito. Quanto maior pFav e lamT, maior cover.
    const p = clamp01(0.5 + 0.62*(pFav-0.5) + 0.10*(lamT-2.55));
    if(line === -0.25) return clamp01(0.56 + (p-0.5)*0.65);
    if(line === -0.5)  return clamp01(0.54 + (p-0.5)*0.75);
    if(line === -0.75) return clamp01(0.51 + (p-0.5)*0.80);
    if(line === -1.0)  return clamp01(0.47 + (p-0.5)*0.88);
    if(line === -1.25) return clamp01(0.43 + (p-0.5)*0.95);
    if(line === -1.5)  return clamp01(0.38 + (p-0.5)*1.02);

    if(line === +0.25) return clamp01(0.55 + (0.5-p)*0.65);
    if(line === +0.5)  return clamp01(0.57 + (0.5-p)*0.75);
    if(line === +0.75) return clamp01(0.60 + (0.5-p)*0.80);
    if(line === +1.0)  return clamp01(0.63 + (0.5-p)*0.88);
    if(line === +1.25) return clamp01(0.66 + (0.5-p)*0.95);
    if(line === +1.5)  return clamp01(0.70 + (0.5-p)*1.02);

    return 0.50;
  }

  // 1ª parte: usar fração do λ_total (típico ~45%)
  const lam1H = clamp(lamT * 0.46, 0.55, 1.80);

  // Cantos: derivar λ_cantos com base em (HS/AS) e/ou cantos recentes (quando existem)
  function avgCorners(div, team, side, n){
    // tenta usar histórico (HC/AC) via TEAM_STATS snapshots: não existe diretamente, então fallback via goals proxy
    // nota: este ficheiro não guarda cantos por jogo por equipa no TEAM_STATS; usamos heurística a partir de golos/estilo
    const baseC = 9.6 + 3.2*(egDelta) + 1.0*(balance-0.5);
    return clamp(baseC, 7.0, 12.8);
  }
  const lamC = clamp(avgCorners(div, home, 'home', 10), 6.5, 13.5);
  // Cartões: removido (apenas mercados por jogo)

  
  // Margens típicas por família de mercado (aprox.) para aproximar odds de casas reais.
  // Nota: aqui "margin" é um ajuste pequeno à probabilidade (vig), não um cap/floor.
  function marginByFamily(fam, code){
    const f = String(fam||'').toUpperCase();
    const c = String(code||'').toUpperCase();

    if(f.includes('CORN') || f.includes('CANTO')) return 0.03;  // cantos (linhas seguras costumam ter vig baixo)
    if(f === 'BTTS' || f.includes('AMBAS') || f.includes('MARCA')) return 0.05;
    if(f.includes('AH') || f.includes('HANDICAP')) return 0.045;
    if(f.includes('TOTAL') || f.includes('GOLO') || f.includes('GOALS') || f.includes('HT')) return 0.045;
    if(f.includes('RESULT') || f.includes('RES') || f.includes('DNB') || f.includes('DC') || f.includes('1X2')) return 0.03;

    // especiais/combo/correct score tendem a ter vig maior
    if(f.includes('SPECIAL') || f.includes('COMBO')) return 0.07;

    return 0.05;
  }

// ---- odds: reais se existirem; caso contrário estimadas ----
  function oddOrEstimate(prob, realOdd, margin, meta, code, fam){
    // "realOdd" só deve ser tratado como odd real quando vem do ficheiro.
    // Caso contrário, consideramos estimada (mesmo que seja numérica) para efeitos de UI.
    const fromFile = !!(meta && meta.realOdd === true);

    const o = (fromFile && realOdd && isFinite(realOdd) && realOdd > 1.01)
      ? Number(realOdd)
      : (ALLOW_ESTIMATED_ODDS ? priceFromProb(prob, (margin!=null?margin:marginByFamily(fam, code))) : null);

    if(o==null) return null;
    return Math.max(MIN_ODD, o);
  }

  // ---- odds (UI): tornar odds estimadas mais realistas sem mexer na seleção (Odd continua a ser a base do motor) ----
  function displayOddForUI(prob, baseOdd, fam, isReal){
    if(baseOdd==null || !isFinite(baseOdd)) return null;
    if(isReal) return Number(baseOdd);

    // Apenas apresentação: tornar odds estimadas mais "realistas" (evitar repetir 1.25)
    // Nota: NÃO mexe na seleção (o motor continua a usar x.Odd).
    const f = String(fam||'').toUpperCase();
    let minO=1.30, maxO=3.50;

    // Normalização por família (aceita variantes do v9 / labels PT)
    // Objetivo: refletir melhor a distribuição típica de odds de uma casa real,
    // evitando pisos artificiais (ex.: 1.30+) que criam discrepância no "slip".
    if(f.includes('CORN') || f.includes('CANTO')){
      minO=1.15; maxO=3.20;           // cantos
    } else if(f === 'BTTS' || f.includes('AMBAS') || f.includes('MARCA')){
      minO=1.25; maxO=3.60;           // ambas marcam
    } else if(f.includes('AH') || f.includes('HANDICAP')){
      minO=1.15; maxO=3.60;           // handicap asiático
    } else if(f.includes('TOTAL') || f.includes('GOLO') || f.includes('GOALS') || f.includes('HT')){
      minO=1.12; maxO=2.90;           // golos (O/U, 1ª parte)
    } else if(f.includes('RES') || f.includes('RESULT') || f.includes('DNB') || f.includes('DC') || f.includes('1X2')){
      minO=1.05; maxO=2.60;           // resultado (inclui DC/DNB estimado)
    }

    let o = Number(baseOdd);

    // Se veio "colado" no floor do motor (MIN_ODD), sobe para não parecer bug.
    // Determinístico (sem aleatoriedade) para não oscilar entre refreshes.
    if(o <= (1.05 + 1e-9)){
      const jig = (Math.round(clamp01(prob)*1000) % 9) * 0.01; // 0.00..0.08
      o = minO + jig;
    }

    // Caso geral: respeitar limites e arredondar
    o = Math.min(maxO, Math.max(minO, o));
    return Number(o.toFixed(2));
  }


  // ---- builder de mercados ----
  const mk = [];
  function pushMarket(code, label, fam, prob, odd, meta){
    prob = clamp01(prob);
    const ds = meta && (meta.ds!=null?meta.ds:meta.dataStrength);
    // 1) calibração por família (sigmoid)
    prob = calibSigmoid(fam, prob, ds);
    // 2) alinhar ao mercado quando há odd real
    if(meta && meta.realOdd === true && odd){
      prob = alignToMarket(prob, odd, fam, ds);
    }
    if(!(prob>0)) return;
    const isRealOdd = !!(meta && meta.realOdd === true);
    const o = oddOrEstimate(prob, odd, meta && meta.margin, meta, code, fam);
    const oDisp = displayOddForUI(prob, o, fam, isRealOdd, meta, code);
    if(o==null) return;
    const pAdj = dampProb(prob, o);
    const ev = (pAdj * o - 1);

    mk.push({
      code,
      label,
      fam,
      prob: pAdj,
      rawProb: prob,
      odd: o,
      ev,
      // campos esperados noutros pontos
      Prob: pAdj,
      Odd: o,
      OddDisp: oDisp,
      EV: ev,
      Family: fam,
      Label: label,
      Code: code
    });
  }

  // ===== 1X2 / DC / DNB =====
  const oddH = base.odds.H || priceFromProb(Hm,0.06);
  const oddD = base.odds.D || priceFromProb(Dm,0.06);
  const oddA = base.odds.A || priceFromProb(Am,0.06);

  pushMarket('1',  `${home} vence`, 'RESULTADO', Hm, oddH, {margin:0.055, realOdd: !!base.odds.H, ds:dataStrength});
  pushMarket('X',  `Empate`,      'RESULTADO', Dm, oddD, {margin:0.055, realOdd: !!base.odds.D, ds:dataStrength});
  pushMarket('2',  `${away} vence`, 'RESULTADO', Am, oddA, {margin:0.055, realOdd: !!base.odds.A, ds:dataStrength});

  // Dupla chance
  pushMarket('DC1X', `Dupla chance 1X`, 'RESULTADO', blendProb(clamp01(Hm+Dm), clamp01(base.H+base.D), 0.65), null, {margin:0.03});
  pushMarket('DC12', `Dupla chance 12`, 'RESULTADO', blendProb(clamp01(Hm+Am), clamp01(base.H+base.A), 0.65), null, {margin:0.04});
  pushMarket('DCX2', `Dupla chance X2`, 'RESULTADO', blendProb(clamp01(Dm+Am), clamp01(base.D+base.A), 0.65), null, {margin:0.03});

  // DNB (aprox: remove draw)
  const pH_dnb = blendProb(clamp01(Hm / Math.max(0.01, Hm+Am)), clamp01(base.H / Math.max(0.01, base.H+base.A)), 0.65);
  const pA_dnb = blendProb(clamp01(Am / Math.max(0.01, Hm+Am)), clamp01(base.A / Math.max(0.01, base.H+base.A)), 0.65);
  pushMarket('DNBH', `DNB ${home}`, 'RESULTADO', pH_dnb, null, {margin:0.03});
  pushMarket('DNBA', `DNB ${away}`, 'RESULTADO', pA_dnb, null, {margin:0.03});

  // ===== Totais (FT) =====
  // Nota: removemos linhas demasiado "seguras" (ex.: 5.5) para evitar picks pouco vendáveis.
  const totalLines = [1.5,2.5,3.5,4.5];
  for(const ln of totalLines){
    const pO = totalProbOver(ln, lamT);
    const pU = totalProbUnder(ln, lamT);
    pushMarket(`OVER${String(ln).replace('.','')}`, `Over ${ln} golos`, 'TOTAL', pO, (ln===2.5?readOdd(row,COLS.OVER25):(ln===1.5?readOdd(row,COLS.OVER15):null)), {margin:0.045});
    pushMarket(`UNDER${String(ln).replace('.','')}`, `Under ${ln} golos`, 'TOTAL', pU, (ln===2.5?readOdd(row,COLS.UNDER25):null), {margin:0.045});
  }

  // Totais alternativos "Team Totals"
  // ===== Team totals (removido: apenas mercados por jogo)


  // ===== BTTS / Clean sheets =====
  pushMarket('BTTS_Y', `Ambas marcam (Sim)`, 'BTTS', PBTTS, readOdd(row,COLS.BTTS_Y), {margin:0.045});
  pushMarket('BTTS_N', `Ambas marcam (Não)`, 'BTTS', 1-PBTTS, readOdd(row,COLS.BTTS_N), {margin:0.045});
  // Clean sheets (removido: mercados por equipa)

  // ===== Asian Handicap (principal + alternativas) =====
  // Favorito e outsider (linhas mais comuns)
  const fav = favH ? 'H' : 'A';
  const dog = favH ? 'A' : 'H';

  const ahLines = [-0.25,-0.5,-0.75,-1.0,-1.25,-1.5, +0.25,+0.5,+0.75,+1.0,+1.25,+1.5];
  for(const ln of ahLines){
    const pCov = ahCoverProb(ln);
    if(fav==='H'){
      if(ln<0) pushMarket(`AH${String(ln).replace('.','')}_H`, `${home} AH ${ln}`, 'AH', pCov, null, {margin:0.045});
      if(ln>0) pushMarket(`AH${String(ln).replace('.','')}_A`, `${away} AH +${ln}`, 'AH', pCov, null, {margin:0.04});
    }else{
      if(ln<0) pushMarket(`AH${String(ln).replace('.','')}_A`, `${away} AH ${ln}`, 'AH', pCov, null, {margin:0.045});
      if(ln>0) pushMarket(`AH${String(ln).replace('.','')}_H`, `${home} AH +${ln}`, 'AH', pCov, null, {margin:0.04});
    }
  }

  // Mantém compatibilidade com códigos antigos
  const oddAHm1_H  = readOdd(row, COLS.AHm1_H);
  const oddAHm1_A  = readOdd(row, COLS.AHm1_A);
  const oddAHm15_H = readOdd(row, COLS.AHm15_H);
  const oddAHm15_A = readOdd(row, COLS.AHm15_A);
  const oddAHp05_H = readOdd(row, COLS.AHp05_H);
  const oddAHp05_A = readOdd(row, COLS.AHp05_A);

  if(oddAHm1_H)  pushMarket('AHm1_H',  `${home} AH -1`,   'AH', ahCoverProb(-1.0),  oddAHm1_H,  {margin:0.05});
  if(oddAHm1_A)  pushMarket('AHm1_A',  `${away} AH -1`,   'AH', ahCoverProb(-1.0),  oddAHm1_A,  {margin:0.05});
  if(oddAHm15_H) pushMarket('AHm15_H', `${home} AH -1.5`, 'AH', ahCoverProb(-1.5),  oddAHm15_H, {margin:0.05});
  if(oddAHm15_A) pushMarket('AHm15_A', `${away} AH -1.5`, 'AH', ahCoverProb(-1.5),  oddAHm15_A, {margin:0.05});
  if(oddAHp05_H) pushMarket('AHp05_H', `${home} AH +0.5`, 'AH', ahCoverProb(+0.5),  oddAHp05_H, {margin:0.05});
  if(oddAHp05_A) pushMarket('AHp05_A', `${away} AH +0.5`, 'AH', ahCoverProb(+0.5),  oddAHp05_A, {margin:0.05});

  // ===== 1ª Parte (HT) =====
  // Over/Under HT
  const htLines = [0.5,1.5,2.5];
  for(const ln of htLines){
    pushMarket(`HT_O${String(ln).replace('.','')}`, `1ª Parte Over ${ln} golos`, 'TOTAL', totalProbOver(ln, lam1H), null, {margin:0.05});
    pushMarket(`HT_U${String(ln).replace('.','')}`, `1ª Parte Under ${ln} golos`, 'TOTAL', totalProbUnder(ln, lam1H), null, {margin:0.05});
  }
  // HT 1X2 aproximado a partir de share e draw mais alto
  const drawHT = clamp01(0.38 - 0.10*(lam1H-1.05)); // mais golos -> menos empate ao intervalo
  let pHTH = clamp01((1-drawHT) * (shareH));
  let pHTA = clamp01((1-drawHT) * (1-shareH));
  let pHTD = clamp01(drawHT);
  const sHT = pHTH+pHTA+pHTD || 1; pHTH/=sHT; pHTA/=sHT; pHTD/=sHT;
  pushMarket('HT_1', `Intervalo: ${home} vence`, 'RESULTADO', pHTH, null, {margin:0.07});
  pushMarket('HT_X', `Intervalo: Empate`, 'RESULTADO', pHTD, null, {margin:0.07});
  pushMarket('HT_2', `Intervalo: ${away} vence`, 'RESULTADO', pHTA, null, {margin:0.07});

  // ===== Cantos (FT) =====
  const cornerLines = [6.5,7.5];
  for(const ln of cornerLines){
    const pO = totalProbOver(ln, lamC);
    const pU = totalProbUnder(ln, lamC);
    // compatibilidade: CORN_O75 (7.5)
    if(ln===7.5){
      pushMarket('CORN_O75', `Cantos Over 7.5`, 'CORNERS', pO, null, {margin:0.03});
      pushMarket('CORN_U75', `Cantos Under 7.5`, 'CORNERS', pU, null, {margin:0.03});
    }else{
      pushMarket(`CORN_O${String(ln).replace('.','')}`, `Cantos Over ${ln}`, 'CORNERS', pO, null, {margin:0.03});
      pushMarket(`CORN_U${String(ln).replace('.','')}`, `Cantos Under ${ln}`, 'CORNERS', pU, null, {margin:0.07});
    }
  }

  // Cantos: equipa (removido — não aceitamos props por equipa)
  // ===== Cartões (FT) removido =====



  // ===== “Especiais” adicionais (LuxTIPS) =====
  // Golos em ambas as partes (Sim/Não): pelo menos 1 golo em cada parte (aprox. por Poisson)
  const lam2H = Math.max(0.05, lamT - lam1H);
  const pG1 = 1 - Math.exp(-lam1H);
  const pG2 = 1 - Math.exp(-lam2H);
  const pBothHalvesYes = clamp01(pG1 * pG2);
  pushMarket('BH_Y', `Golo em ambas as partes (Sim)`, 'SPECIAL', pBothHalvesYes, readOdd(row,COLS.BH_Y), {margin:0.075});
  pushMarket('BH_N', `Golo em ambas as partes (Não)`, 'SPECIAL', 1 - pBothHalvesYes, readOdd(row,COLS.BH_N), {margin:0.075});

  // Vitória ou Empate + Over 1.5 (1X+O1.5) e (X2+O1.5)
  // Cálculo por soma conjunta (Poisson independente) até 10 golos (restante é residual).
  function jointSum(cond){
    let sum = 0;
    const maxG = 10;
    for (let hg=0; hg<=maxG; hg++){
      const ph = poisP(hg, lamH);
      for (let ag=0; ag<=maxG; ag++){
        const pa = poisP(ag, lamA);
        if (cond(hg,ag)) sum += ph*pa;
      }
    }
    return clamp01(sum);
  }
  const p1X_O15 = jointSum((hg,ag)=> (hg+ag)>=2 && (hg>=ag));
  const pX2_O15 = jointSum((hg,ag)=> (hg+ag)>=2 && (ag>=hg));
  pushMarket('1X_O15', `${home} ganha ou empata + Over 1.5`, 'COMBO', p1X_O15, null, {margin:0.08});
  pushMarket('X2_O15', `${away} ganha ou empata + Over 1.5`, 'COMBO', pX2_O15, null, {margin:0.08});

  // ===== “Especiais” populares =====
  // Removido: mercados por equipa (ex.: "equipa marca") — apenas aceitamos por equipa em 1X2/DC/DNB/AH.
  // “Mais de X golos no jogo” já está em totals, mas reforça compatibilidade com códigos antigos
  pushMarket('OVER15', `Over 1.5 golos`, 'TOTAL', totalProbOver(1.5, lamT), readOdd(row,COLS.OVER15), {margin:0.04});
  pushMarket('OVER25', `Over 2.5 golos`, 'TOTAL', Pover25, readOdd(row,COLS.OVER25), {margin:0.04});
  pushMarket('UNDER25', `Under 2.5 golos`, 'TOTAL', 1-Pover25, readOdd(row,COLS.UNDER25), {margin:0.04});

  // Correct score (limitado a 0..4 por lado; útil como “imaginário”, mas sem inundar picks)
  // Nota: não é para picks core, mas para a grelha de mercados ficar completa.
  function correctScoreProb(hg, ag){
    return poisP(hg, lamH) * poisP(ag, lamA);
  }
  const csMax = 4;
  for(let hg=0; hg<=csMax; hg++){
    for(let ag=0; ag<=csMax; ag++){
      const p = correctScoreProb(hg, ag);
      if(p < 0.035) continue; // corta ruído
      pushMarket(`CS_${hg}_${ag}`, `Resultado correto ${hg}-${ag}`, 'RESULTADO', p, null, {margin:0.11});
    }
  }

  // HT/FT (simplificado: assume independência parcial)
  const pFT_H = Hm, pFT_D = Dm, pFT_A = Am;
  const combos = [
    ['HH', pHTH*pFT_H, `HT/FT: ${home}/${home}`],
    ['HD', pHTH*pFT_D, `HT/FT: ${home}/Empate`],
    ['HA', pHTH*pFT_A, `HT/FT: ${home}/${away}`],
    ['DH', pHTD*pFT_H, `HT/FT: Empate/${home}`],
    ['DD', pHTD*pFT_D, `HT/FT: Empate/Empate`],
    ['DA', pHTD*pFT_A, `HT/FT: Empate/${away}`],
    ['AH', pHTA*pFT_H, `HT/FT: ${away}/${home}`],
    ['AD', pHTA*pFT_D, `HT/FT: ${away}/Empate`],
    ['AA', pHTA*pFT_A, `HT/FT: ${away}/${away}`],
  ];
  for(const [code,p,label] of combos){
    if(p < 0.08) continue;
    pushMarket(`HTFT_${code}`, label, 'RESULTADO', p, null, {margin:0.10});
  }

  // ordenar mercados (opcional) – os consumidores deste método ordenam depois,
  // mas deixamos aqui uma ordenação base “por qualidade” para facilitar debug.
  mk.sort((a,b)=> (b.prob - a.prob) + 0.08*((b.ev||0)-(a.ev||0)));

  // 1X2 (lista separada usada noutros pontos do ficheiro)
  // Usa probs já FLB e odds do ficheiro quando existirem.
  let H1=Hm, D1=Dm, A1=Am;
  const oneX2 = [
    {side:'1',prob:H1,odd:oddH,ev:(H1*oddH-1)},
    {side:'X',prob:D1,odd:oddD,ev:(D1*oddD-1)},
    {side:'2',prob:A1,odd:oddA,ev:(A1*oddA-1)}
  ];

  
  // ===== Anti-UNDER (regra absoluta do produto) =====
  // Remove qualquer mercado "Under"/"Menos de" (golos, cantos, HT, etc.).
  const mkFiltered = mk.filter(m => {
    const lbl = String(m.label||'').toLowerCase();
    const code = String(m.code||'').toLowerCase();
    return !(lbl.includes('under') || lbl.includes('menos') || code.startsWith('u') || code.includes('_u'));
  });

  return {
    base,
    model:{H:Hm,D:Dm,A:Am,Pover25,PBTTS,pFav,favH,favTeam,dogTeam,lamT,lamH,lamA,lamC},
    mk: mkFiltered,
    oneX2,
    calib:c
  };
}



function chooseByLeague(div, markets, diversity){
  const R = LIGA_REGRAS[div] || { prefer: ['MISTO'], evitar: [] };
  const pref  = new Set(R.prefer);
  const avoid = new Set(R.evitar);
  const divCount = diversity || { fam:{}, code:{} };

  function getCount(map, k){ return (map && map[k]) ? map[k] : 0; }

  // Normalização: se a odd real existir, usamos-na; caso contrário usamos odd "justa" do motor
  function oddOk(o){ return (typeof o === 'number' && isFinite(o) && o>1.01) ? o : null; }

  // Preferência de "vendável": odds típicas de picks diárias (nem demasiado baixas nem demasiado altas)
  function oddTargetScore(o){
    if(!o) return 0.0;
    // alvo ~1.55 com tolerância
    const t = 1.55, w = 0.55;
    const d = Math.abs(o - t);
    return Math.max(0, 1 - (d/w)); // 0..1
  }

  let best = null;

  for (const m of markets.mk) {
    if (avoid.has(m.fam)) continue;

    // família desligada no UI
    const el = document.getElementById('fam' + m.fam);
    if (el && !el.checked) continue;

    const minProb = MIN_PROB_FAM[m.fam] ?? 0.0;
    const minEv   = MIN_EV_FAM[m.fam]   ?? -0.35; // ligeiramente mais permissivo
    if (m.prob < minProb) continue;
    if (typeof m.ev === 'number' && m.ev < minEv) continue;

    // boost por preferências da liga
    const boost =
      (pref.has('OVER')  && (m.fam==='TOTAL' || m.code.startsWith('OVER'))) ||
      (pref.has('BTTS')  && (m.code === 'BTTS_Y' || m.code === 'BTTS_N')) ||
      (pref.has('RESULTADO') && m.fam === 'RESULTADO') ||
      (pref.has('AH') && m.fam === 'AH') ||
      (pref.has('CORNERS') && m.fam === 'CORNERS')
        ? 1.05
        : (pref.has('MISTO') ? 1.01 : 1.0);

    // bónus por tipo de mercado (market mix)
    const typeBonus =
      (m.code === 'OVER15'       ? 0.06 : 0) +
      (m.code === 'UNDER25'      ? 0.01 : 0) +
      (m.code === 'BTTS_Y'       ? 0.05 : 0) +
      (m.code === 'BTTS_N'       ? 0.02 : 0) +
      (m.fam === 'DC'            ? 0.04 : 0) +
      (m.fam === 'DNB'           ? 0.04 : 0) +
      (m.fam === 'AH'            ? 0.03 : 0) +
      (m.fam === 'CORNERS'       ? 0.03 : 0) +
      (m.fam === 'RESULTADO'     ? -0.01 : 0);

    // diversidade: penalizar repetição de famílias/códigos
    const cFam  = getCount(divCount.fam,  m.fam);
    const cCode = getCount(divCount.code, m.code);
    const diversityPenalty = 1 / (1 + cFam*0.55 + cCode*0.90);

    // odds: preferir odds "vendáveis"
    const o = oddOk(m.odd);
    const oddScore = oddTargetScore(o); // 0..1

    // Penalizar odds demasiado baixas (picks "seguras" e pouco vendáveis)
    const lowOddPenalty = (!o ? 0.90 : (o < 1.32 ? 0.55 : (o < 1.40 ? 0.78 : 1.0)));

    // Penalizar linhas "ultra-seguras" nos totais (ex.: Under 4.5)
    const cowardPenalty =
      (m.fam==='TOTAL' && m.code==='UNDER45') ? 0.70 :
      (m.fam==='TOTAL' && m.code==='UNDER35') ? 0.88 :
      1.0;

    // EV entra como ajuste suave (não domina)
    const evAdj = (typeof m.ev==='number' && isFinite(m.ev)) ? Math.max(-0.20, Math.min(0.35, m.ev)) : 0;

    // score final
    const score =
      ((m.prob + typeBonus) * boost)
      * (0.85 + 0.30*oddScore)
      * diversityPenalty * lowOddPenalty * cowardPenalty
      + evAdj*0.10;

    if (!best || score > best._s) {
      best = Object.assign({ _s: score }, m);
    }
  }

  return best;
}

function stakeKelly(prob, odd){
  const b=Math.max(0, odd-1), p=prob, q=1-p;
  const f = (b>0)? Math.max(0, ((b*p)-q)/b) : 0;
  return Math.min(f, 0.02); // cap 2%
}
function stakePct(prob, odd){
  const b=Math.max(0, odd-1), p=prob, q=1-p;
  const k=Math.max(0, ((b*p)-q)/(b||1));
  const baseCap=(p>=0.72)?0.02:(p>=0.62?0.01:(p>=0.55?0.006:0.003));
  let s=Math.min(k, baseCap);
  if(document.getElementById('useKelly').checked){
    s=Math.min(s, stakeKelly(prob, odd));
  }
  return s;
}
function clvFor(row, pickSide){
  const oOpen = (pickSide==='1')? +row.B365H : (pickSide==='X' ? +row.B365D : +row.B365A);
  const oClose= (pickSide==='1')? +row.CloseH : (pickSide==='X' ? +row.CloseD : +row.CloseA);
  if(oOpen>0 && oClose>0) return (oClose/oOpen) - 1;
  return null;
}


function explain(div,row,choice,pack){
  const liga = (LIGA_REGRAS[div]?.nome) || div || 'Liga';
  const m = pack.model || {};
  const b = pack.base || {};
  const probPct = (choice.prob*100).toFixed(1);
  const conf = choice.conf || 'média';
  const dataJogo = dtLabelFromRow(row);
  const casa = row.HomeTeam || 'equipa da casa';
  const fora = row.AwayTeam || 'equipa visitante';
  const label = choice.label || '';
  const ts = tsFromRow(row);

  const snap = leagueTableSnapshot(div, ts);
  const fraseCasa = sentenceRecord(div, casa, 'home', 10);
  const fraseFora = sentenceRecord(div, fora, 'away', 10);
  const tabelaCasa = sentenceTable(div, casa, ts);
  const tabelaFora = sentenceTable(div, fora, ts);
  const motivCasa = sentenceMotivation(div, casa, ts);
  const motivFora = sentenceMotivation(div, fora, ts);
  const h2h = sentenceH2H(div, casa, fora, ts, 5);

  let fraseConf = '';
  if (conf === 'alta') {
    fraseConf = 'O modelo gera um sinal forte para este lado do mercado, sustentado por desempenho recente e métricas internas.';
  } else if (conf === 'média') {
    fraseConf = 'Há valor estatístico identificado, embora com maior variabilidade natural neste tipo de jogo.';
  } else {
    fraseConf = 'Trata-se de uma abordagem mais ousada, indicada para perfis de aposta confortáveis com maior risco.';
  }

  const implProbPct = (100/choice.odd).toFixed(1);

   let explicacaoMercado = '';
  const code = (choice.code || '').toUpperCase();

  // --- Resultado protegido (DNB / DC) ---
  if (code === 'DC1X') {
    explicacaoMercado =
      `Protegemos o lado do ${casa}: a aposta ganha com vitória da equipa da casa ou empate. ` +
      `Os dados do modelo indicam que o ${casa} tem grande probabilidade de, pelo menos, não perder, ` +
      `por isso faz mais sentido blindar o cenário 1X em vez de arriscar num “1” puro.`;
  } else if (code === 'DCX2') {
    explicacaoMercado =
      `Protegemos o lado do ${fora}: a aposta é vencedora com empate ou triunfo do visitante. ` +
      `A consistência recente do ${fora} fora de casa e a fragilidade do ${casa} tornam o X2 uma forma segura ` +
      `de seguir o favoritismo do visitante sem precisar obrigatoriamente da vitória.`;
  } else if (code === 'DNBH') {
    explicacaoMercado =
      `Assumimos o favoritismo do ${casa}, mas com rede de segurança: se o jogo terminar empatado, o investimento é devolvido. ` +
      `As métricas de forma e classificação apontam vantagem para o ${casa}, daí a escolha de DNB em vez do 1X2 tradicional.`;
  } else if (code === 'DNBA') {
    explicacaoMercado =
      `Exploramos o bom momento do ${fora} com proteção total ao empate. ` +
      `O modelo vê o visitante muito competitivo neste contexto, ` +
      `pelo que o DNB permite capturar a superioridade do ${fora} sem ficar exposto a um empate traiçoeiro.`;

  // --- Golos (Over / Under) ---
  } else if (code === 'OVER25') {
    explicacaoMercado =
      'O jogo tem perfil para ser aberto: ambas as equipas produzem muitas ocasiões, ' +
      'têm média de golos elevada e defesas longe de serem intransponíveis. ' +
      'Somando a tendência recente de partidas com 3+ golos, o Over 2.5 encaixa bem no padrão estatístico deste confronto.';
  } else if (code === 'OVER15') {
    explicacaoMercado =
      'A probabilidade de termos pelo menos dois golos é muito alta. ' +
      'O histórico das duas equipas mostra jogos raramente terminarem 0-0 ou 1-0, ' +
      'por isso o Over 1.5 funciona como uma abordagem mais conservadora, com grande taxa de acerto esperada.';
  } else if (code === 'UNDER25') {
    explicacaoMercado =
      'Os números apontam para um encontro mais controlado: ritmo médio de golos baixo, ' +
      'equipas com alguma solidez defensiva e tendência para jogos decididos por marcadores curtos. ' +
      'Neste contexto, o Under 2.5 aproveita a probabilidade elevada de termos até dois golos.';

  // --- BTTS ---
  } else if (code === 'BTTS_Y') {
    explicacaoMercado =
      'Ambas as equipas mostram capacidade ofensiva consistente e defesas vulneráveis. ' +
      'A frequência com que marcam e sofrem, aliada à forma recente, aumenta bastante a probabilidade ' +
      'de vermos golo dos dois lados, justificando o “Ambas marcam — Sim”.';
  } else if (code === 'BTTS_N') {
    explicacaoMercado =
      'Os dados sugerem que pelo menos um dos lados terá muitas dificuldades para marcar: ' +
      'seja por falta de criação ofensiva, seja pela solidez defensiva do adversário. ' +
      'Isso puxa a probabilidade para “Ambas marcam — Não”, que se torna mais interessante do que o mercado de golos genérico.';

  // --- Cantos ---
  } else if (code === 'CORN_O75') {
    explicacaoMercado =
      'Este encontro deve ter bastante volume ofensivo, com muitas chegadas às áreas e jogo pelos flancos. ' +
      'O histórico de cantos das duas equipas, somado à forma como atacam (cruzamentos, bolas paradas), ' +
      'faz com que a linha de mais de 7.5 cantos esteja bem suportada estatisticamente.';

  // --- Asian Handicap ---
  } else if (code === 'AHM1' || code === 'AHM15') {
    explicacaoMercado =
      'O modelo vê uma diferença clara de qualidade e momento entre as equipas. ' +
      'O handicap negativo exige vitória por margem dilatada, mas oferece uma odd melhor ' +
      'para um cenário em que o favorito tende a controlar o jogo e criar muitas oportunidades.';
  } else if (code === 'AHP05') {
    explicacaoMercado =
      'Trata-se de um jogo equilibrado, em que o underdog tem argumentos para pontuar. ' +
      'O AH +0.5 protege o empate a favor dessa equipa, o que faz sentido quando o modelo indica ' +
      'que a probabilidade de ela não perder é claramente superior ao que a odd sugere.';

  // --- 1X2 directo (se algum dia for usado aqui) ---
  } else if (label.startsWith('1X2 - 1')) {
    explicacaoMercado =
      `Vamos directamente na vitória do ${casa}. A probabilidade calculada pelo modelo é bem superior à implícita na odd, ` +
      `e o contexto de forma/tabela sustenta o favoritismo claro da equipa da casa.`;
  } else if (label.startsWith('1X2 - 2')) {
    explicacaoMercado =
      `Assumimos a vitória do ${fora}. O visitante chega com melhor momento, ` +
      `estatísticas ofensivas superiores e um encaixe táctico favorável, ` +
      `pelo que o “2” apresenta uma relação risco/retorno muito interessante.`;
  } else if (label.startsWith('1X2 - X')) {
    explicacaoMercado =
      'O modelo aproxima bastante as probabilidades de vitória de cada lado, ' +
      'com tendência para jogo equilibrado e marcado por muito equilíbrio no meio-campo. ' +
      'Neste cenário, o empate ganha peso e justifica a entrada directa no X.';

  // --- fallback muito mais neutro (casos raros) ---
  } else {
    explicacaoMercado =
      'Este mercado é aquele onde o modelo encontra melhor equilíbrio entre probabilidade real e odd oferecida, ' +
      'tendo em conta forma recente, contexto de liga e padrão estatístico do jogo.';
  }


  let header = `${liga}: ${casa} vs ${fora} — ${dataJogo}`;
  if (snap && snap.matchDay) {
    const jornada = snap.matchDay + 1;
    header += ` (Jornada ${jornada})`;
  }

  const linhas = [
    `<strong>Previsão do encontro</strong>`,
    header,
    '',
    `<strong>Porque escolhemos esta pick?</strong>`,
    `• Mercado: ${label}`,
    `• Probabilidade estimada pelo modelo: ${probPct}%`,
    `• Odd actual: ${choice.odd.toFixed(2)} `,
    `• ${explicacaoMercado}`
  ];

  // Odds 1X2 (se existirem)
  const odd1 = readOdd(row, ['B365H','HomeOdd','PSH','OddsH','OH']);
  const oddX = readOdd(row, ['B365D','DrawOdd','PSD','OddsD','OD']);
  const odd2 = readOdd(row, ['B365A','AwayOdd','PSA','OddsA','OA']);

  if (odd1 || oddX || odd2){
    linhas.push('');
    linhas.push('<strong>Odds principais (1X2)</strong>');
    linhas.push(`• Vitória ${casa}: ${odd1 ? odd1.toFixed(2) : '-'}`);
    linhas.push(`• Empate: ${oddX ? oddX.toFixed(2) : '-'}`);
    linhas.push(`• Vitória ${fora}: ${odd2 ? odd2.toFixed(2) : '-'}`);
  }

  if (snap && (tabelaCasa || tabelaFora)) {
    linhas.push('');
    linhas.push('<strong>Enquadramento na tabela</strong>');
    if (tabelaCasa) linhas.push(`• ${tabelaCasa}`);
    if (tabelaFora) linhas.push(`• ${tabelaFora}`);
    if (motivCasa) linhas.push(`• ${motivCasa}`);
    if (motivFora) linhas.push(`• ${motivFora}`);
  }

  if (h2h) {
    linhas.push('');
    linhas.push('<strong>Confrontos directos</strong>');
    linhas.push(`• ${h2h}`);
  }

  if (fraseCasa) {
    linhas.push('');
    linhas.push('<strong>Forma recente do anfitrião</strong>');
    linhas.push(`• ${fraseCasa}`);
  }
  if (fraseFora) {
    linhas.push('');
    linhas.push('<strong>Forma recente do visitante</strong>');
    linhas.push(`• ${fraseFora}`);
  }
  if (fraseConf) {
    linhas.push('');
    linhas.push(`• ${fraseConf}`);
  }

  // Mini-tabelas (últimos jogos + H2H)
  if (HIST_ALL && HIST_ALL.length){
    const lastHome = lastMatchesTeam(div, casa, ts, 5);
    const lastAway = lastMatchesTeam(div, fora, ts, 5);
    const lastH2H = lastMatchesH2H(div, casa, fora, ts, 5);

    if (lastHome.length || lastAway.length){
      linhas.push('');
      let html = '<div class="mini-grid">';
      if (lastHome.length){
        html += '<div class="mini-table"><div class="mini-title">Últimos 5 jogos — '+casa+'</div>';
        html += '<table><thead><tr><th>Data</th><th>Adv.</th><th>Res.</th></tr></thead><tbody>';
        html += lastHome.map(m =>
          '<tr class="mini-row" data-div="'+div+'" data-home="'+m.home+'" data-away="'+m.away+'" data-ts="'+m.ts+'">'+
            '<td>'+m.date+'</td>'+
            '<td>'+m.opp+' ('+m.loc+')</td>'+
            '<td>'+m.score+' <span class="mini-res res-'+m.res+'">'+m.res+'</span></td>'+
          '</tr>'
        ).join('');
        html += '</tbody></table></div>';
      }
      if (lastAway.length){
        html += '<div class="mini-table"><div class="mini-title">Últimos 5 jogos — '+fora+'</div>';
        html += '<table><thead><tr><th>Data</th><th>Adv.</th><th>Res.</th></tr></thead><tbody>';
        html += lastAway.map(m =>
          '<tr class="mini-row" data-div="'+div+'" data-home="'+m.home+'" data-away="'+m.away+'" data-ts="'+m.ts+'">'+
            '<td>'+m.date+'</td>'+
            '<td>'+m.opp+' ('+m.loc+')</td>'+
            '<td>'+m.score+' <span class="mini-res res-'+m.res+'">'+m.res+'</span></td>'+
          '</tr>'
        ).join('');
        html += '</tbody></table></div>';
      }
      html += '</div>';
      linhas.push(html);
    }

    if (lastH2H.length){
      linhas.push('');
      let htmlH = '<div class="mini-table"><div class="mini-title">Confrontos directos — últimos 5</div>';
      htmlH += '<table><thead><tr><th>Data</th><th>Jogo</th></tr></thead><tbody>';
      htmlH += lastH2H.map(m => {
        let homeName = m.home;
        let awayName = m.away;

        const hs = Number(m.score.split('-')[0]);
        const as = Number(m.score.split('-')[1]);

        if (hs > as) homeName = '<strong>'+homeName+'</strong>';
        if (as > hs) awayName = '<strong>'+awayName+'</strong>';

        return (
          '<tr class="mini-row" data-div="'+div+'" data-home="'+m.home+'" data-away="'+m.away+'" data-ts="'+m.ts+'">'+
            '<td>'+m.date+'</td>'+
            '<td>'+homeName+' '+m.score+' '+awayName+'</td>'+
          '</tr>'
        );
      }).join('');
      htmlH += '</tbody></table></div>';
      linhas.push(htmlH);
    }
  }

  // Placeholder das estatísticas (fica IMEDIATAMENTE antes da classificação)
  linhas.push('<div class="mini-stats-panel">Clique num jogo das tabelas acima para ver estatísticas detalhadas (remates, cantos, cartões, etc.).</div>');

  // Classificação da liga (vem logo a seguir ao placeholder)
  const standingsHTML = buildStandingsHTML(div, ts, casa, fora);
  if (standingsHTML){
    linhas.push(standingsHTML);
  }

  return linhas.join('\n');
}
     


let LAST_CHOSEN=[], LAST_1X2=[];
let TEAM_STATS = {};
let HIST_ALL = [];


document.addEventListener('click', function(ev){
  // Se clicar numa mini-row (linha de últimos jogos / H2H) abre estatísticas inline logo a seguir à linha clicada
  const rowEl = ev.target.closest && ev.target.closest('.mini-row');
  if(!rowEl) return;

  const div  = rowEl.getAttribute('data-div');
  const home = rowEl.getAttribute('data-home');
  const away = rowEl.getAttribute('data-away');
  const tsStr = rowEl.getAttribute('data-ts');
  const ts = tsStr ? Number(tsStr) : null;

  if(!div || !home || !away || !HIST_ALL || !HIST_ALL.length) return;

  // procurar no histórico o jogo exacto (por div+equipas+timestamp se existir)
  let matchRow = null;
  for(const r of HIST_ALL){
    if(r.Div !== div) continue;
    if(r.HomeTeam !== home || r.AwayTeam !== away) continue;

    const d = parseHistDate(r);
    if(!d) continue;

    const thisTs = d.getTime();
    if(ts && thisTs !== ts) continue;

    matchRow = r;
    break;
  }
  if(!matchRow) return;

  const card = rowEl.closest('.match-card');
  if(!card) return;
  const body = card.querySelector('.match-body') || card;

  // (1) Se o painel já estiver aberto imediatamente abaixo desta mini-row, fecha (toggle)
  const next = rowEl.nextElementSibling;
  if(next && next.classList && next.classList.contains('mini-stats-panel')){
    next.remove();
    return;
  }

  // (2) Fecha quaisquer outros painéis abertos dentro deste cartão
  body.querySelectorAll('.mini-stats-panel').forEach(p=>p.remove());

  // (3) Injeta o painel imediatamente a seguir à mini-row clicada
  const panel = document.createElement('div');
  panel.className = 'mini-stats-panel';
  panel.innerHTML = buildStatsPanel(matchRow, home, away);

  // A mini-row é <tr>; inserir um <tr> extra para manter a tabela válida
  if(rowEl.tagName === 'TR'){
    const tr = document.createElement('tr');
    tr.className = 'mini-stats-panel';
    const td = document.createElement('td');
    td.colSpan = rowEl.children ? rowEl.children.length : 6;
    td.style.padding = '10px 8px';
    td.innerHTML = panel.innerHTML;
    tr.appendChild(td);
    rowEl.insertAdjacentElement('afterend', tr);
  }else{
    rowEl.insertAdjacentElement('afterend', panel);
  }
});


// === Loading overlay (linear, uma vez de 0 a 100) ===
const loadingOverlay = document.getElementById('loadingOverlay');
const loadingBarFill = loadingOverlay ? loadingOverlay.querySelector('.loading-bar-fill') : null;
const loadingPercent = document.getElementById('loadingPercent');
const loadingTextEl = loadingOverlay ? loadingOverlay.querySelector('.loading-text') : null;

let loadingTimer = null;
let loadingProgress = 0;

const loadingStepsEl = document.getElementById('loadingSteps');
let _loadingSteps = [];
let _loadingStepIdx = -1;
let _loadingStepTimer = null;

function setLoadingSteps(steps){
  _loadingSteps = Array.isArray(steps) ? steps.slice() : [];
  _loadingStepIdx = -1;
  if(!_loadingStepsEl()) return;
  loadingStepsEl.innerHTML = _loadingSteps.map(s => (
    `<div class="loading-step"><span class="loading-dot"></span><span>${s}</span></div>`
  )).join('');
}
function _loadingStepsEl(){ return !!(loadingStepsEl); }

function setLoadingStep(i){
  if(!loadingStepsEl) return;
  const rows = [...loadingStepsEl.querySelectorAll('.loading-step')];
  if(!rows.length) return;
  rows.forEach((r,idx)=>{
    r.classList.toggle('done', idx < i);
    r.classList.toggle('active', idx === i);
  });
  _loadingStepIdx = i;
}

function autoAdvanceLoadingSteps(){
  if(_loadingStepTimer) clearInterval(_loadingStepTimer);
  if(!_loadingSteps || !_loadingSteps.length) return;
  let i = 0;
  setLoadingStep(0);
  _loadingStepTimer = setInterval(()=>{
    i++;
    if(i >= _loadingSteps.length){
      clearInterval(_loadingStepTimer);
      _loadingStepTimer = null;
      return;
    }
    setLoadingStep(i);
  }, 900);
}

function finishLoadingSteps(){
  if(_loadingStepTimer){ clearInterval(_loadingStepTimer); _loadingStepTimer=null; }
  if(!loadingStepsEl) return;
  const rows = [...loadingStepsEl.querySelectorAll('.loading-step')];
  rows.forEach(r=>{ r.classList.remove('active'); r.classList.add('done'); });
}


/**
 * Inicia o overlay de loading.
 * - message: texto a apresentar (opcional)
 * - O nível de progresso sobe de 0 até 99 de forma monótona.
 *   O 100% é reservado para o finishLoading().
 */
function startLoading(message){
  const intro = document.getElementById('introOverlay');
  const bar = document.getElementById('introBarFill');
  const pctEl = document.getElementById('introPercent');
  const status = document.getElementById('introStatus');

  if(intro){
    intro.style.display = 'flex';
  }

  loadingProgress = 0;
  if(bar) bar.style.width = '0%';
  if(pctEl) pctEl.textContent = '0%';
  if(status) status.textContent = message || 'Inicializar motor…';

  // legacy overlay fica escondido
  if(loadingOverlay) loadingOverlay.style.display = 'none';

  if (loadingTimer) clearInterval(loadingTimer);

  loadingTimer = setInterval(() => {
    if (loadingProgress < 99) loadingProgress++;
    const w = loadingProgress + '%';
    if (bar) bar.style.width = w;
    if (pctEl) pctEl.textContent = w;
  }, 60);
}


/**
 * Termina o overlay de loading:
 * - coloca rapidamente a 100%
 * - esconde o overlay
 */
function finishLoading(){
  const intro = document.getElementById('introOverlay');
  const bar = document.getElementById('introBarFill');
  const pctEl = document.getElementById('introPercent');
  const status = document.getElementById('introStatus');

  if (loadingTimer){ clearInterval(loadingTimer); loadingTimer = null; }

  const tick = setInterval(() => {
    if (loadingProgress < 100) loadingProgress += 2;
    if (loadingProgress > 100) loadingProgress = 100;
    const w = loadingProgress + '%';
    if (bar) bar.style.width = w;
    if (pctEl) pctEl.textContent = w;

    if (loadingProgress >= 100){
      clearInterval(tick);
      if(status) status.textContent = 'Concluído';
      window.setTimeout(()=>{
        if(intro){
          intro.classList.add('intro-out');
          window.setTimeout(()=>{
            intro.style.display='none';
            intro.classList.remove('intro-out');
          }, 520);
        }
      }, 220);
    }
  }, 20);
}



// ================= CACHE (RESULTADOS) =================
// Cache desativada (pedido do utilizador):
// - Não reutiliza resultados anteriores
// - Não guarda resultados no localStorage
// Motivo: permitir ver imediatamente alterações de cálculo/seleção.
const RESULTS_CACHE_KEY = 'LUXTIPS_RESULTS_CACHE_DISABLED';
const RESULTS_TTL_MS = 0;

function fixturesSignature(rows){ return String(Date.now()); } // força sempre "novo"
function loadResultsCache(){ return null; }
function saveResultsCache(){ /* cache disabled */ }
function applyCachedResults(){ return false; }
// ================= /CACHE (RESULTADOS) =================



const runBtn = document.getElementById('runBtn');

runBtn.addEventListener('click', async()=>{
  startLoading('A gerar prognósticos...');
  try{
    const bank=parseFloat(document.getElementById('bankroll').value||0);
    const targetParlay=parseFloat(document.getElementById('targetParlay').value||5);
    const maxPorFam=parseInt(document.getElementById('maxPorFam').value||'3',10);
    const onlyHigh=document.getElementById('onlyHigh').checked;
    const mode1x2=document.getElementById('mode1x2').value;
    const fxInput=document.getElementById('fixturesFile');
    const fxFiles=[...fxInput.files];
    if(!fxFiles.length){ alert('Carrega o ficheiro de fixtures.'); return; }
    let fixtures=[];
    for(const f of fxFiles){
      const rows=await readAnyFixtures(f);
      fixtures=fixtures.concat(rows);
    }

    // Normalização das novas ligas (new_league_fixtures / new_leagues_data)
    fixtures = fixtures.map(r=>{
      if(!r) return r;
      if(!r.Div){
        const c=(r.Country||'').trim();
        if(c && COUNTRY_TO_DIV[c]) r.Div = COUNTRY_TO_DIV[c];
      }
      if(!r.HomeTeam && r.Home) r.HomeTeam = r.Home;
      if(!r.AwayTeam && r.Away) r.AwayTeam = r.Away;
      return r;
    });

    // Cache (4h): se os fixtures forem exatamente os mesmos, mostramos logo os últimos resultados
    // sem voltar a recalcular (poupa tempo e evita clicar em "Gerar" novamente).

	    // Ligas a ignorar (não entram em picks/assinatura/cache)
	    const IGNORED = new Set(['EC','E2','E3','SC2','SC3']);

    const usableForSig = fixtures.filter(r =>
      r.HomeTeam &&
      r.AwayTeam &&
      r.Div &&
      !IGNORED.has(r.Div) &&
      (implied1x2(r) != null)
    );
    usableForSig.sort((a,b)=>tsFromRow(a)-tsFromRow(b));

    const fxSig = fixturesSignature(usableForSig);
    const cached = loadResultsCache();
    if (cached && cached.fixturesSig === fxSig){
      const applied = applyCachedResults(cached);
      if (applied){
        finishLoading();
        return;
      }
    }

    // Só lemos o histórico se for necessário recalcular
    const hFiles=[...document.getElementById('historyFiles').files];
    let histAll=[];
    for(const f of hFiles){
      const rows=await readAnyHistory(f);
      histAll=histAll.concat(rows);
    }


  histAll = histAll.map(r=>{
  if(!r) return r;
  if(!r.Div){
    const c=(r.Country||'').trim();
    if(c && COUNTRY_TO_DIV[c]) r.Div = COUNTRY_TO_DIV[c];
  }
  if(!r.HomeTeam && r.Home) r.HomeTeam = r.Home;
  if(!r.AwayTeam && r.Away) r.AwayTeam = r.Away;
  if(r.HG != null && r.FTHG == null) r.FTHG = r.HG;
  if(r.AG != null && r.FTAG == null) r.FTAG = r.AG;
  if(r.Res && !r.FTR) r.FTR = r.Res;

  // Já não inventamos remates/cantos/cartões.
  return r;
});


    const opts={
      nTop5: parseInt(document.getElementById('nTop5').value||'5',10),
      nMed:  parseInt(document.getElementById('nMed').value||'4',10),
      nSeg:  parseInt(document.getElementById('nSeg').value||'3',10),
      decayPreset: document.getElementById('decayPreset').value,
      overrides: document.getElementById('overrides').value,
      bayesAlpha: parseInt(document.getElementById('bayesAlpha').value||'0',10)
    };
    const calib=await computeLeagueCalib(histAll, opts);

    TEAM_STATS = computeTeamStats(histAll);
    HIST_ALL = histAll;

	    // (IGNORED já declarado acima)

const usable = fixtures.filter(r =>
  r.HomeTeam &&
  r.AwayTeam &&
  r.Div &&
  !IGNORED.has(r.Div) &&
  (implied1x2(r) != null)
);

    usable.sort((a,b)=>tsFromRow(a)-tsFromRow(b));

    const items=[]; const oneX2List=[];
    window.__PICK_DIVERSITY__ = window.__PICK_DIVERSITY__ || {fam:{}, code:{}};
    window.__PICK_DIVERSITY__.fam = {};
    window.__PICK_DIVERSITY__.code = {};
    for(const r of usable){
      const pack=buildMarkets(r, calib);
      const pick=chooseByLeague(r.Div, pack, window.__PICK_DIVERSITY__);
      const ts = tsFromRow(r);
      if(pick){
        // atualizar diversidade global
        const d=window.__PICK_DIVERSITY__;
        d.fam[pick.fam] = (d.fam[pick.fam]||0)+1;
        d.code[pick.code]= (d.code[pick.code]||0)+1;
        const stake=stakePct(pick.prob, pick.odd);
        const stakeEUR=stake*bank;
        // Normalizar hora dos fixtures (Excel time, string, etc.)
const rawTime =
  (r.Time   ?? r.Kickoff ?? r.Hour ?? r.Hora ?? '');  // usar ?? para aceitar 0

let timeStr = '';

if (rawTime instanceof Date){
  const h = rawTime.getHours();
  const m = rawTime.getMinutes();
  const pad = n => String(n).padStart(2,'0');
  timeStr = pad(h)+':'+pad(m);
} else if (typeof rawTime === 'number' && !isNaN(rawTime)){
  // Excel time: fração do dia (0–1)
  const totalMinutes = Math.round(rawTime * 24 * 60);
  const h = Math.floor(totalMinutes / 60) % 24;
  const m = totalMinutes % 60;
  const pad = n => String(n).padStart(2,'0');
  timeStr = pad(h)+':'+pad(m);
} else if (rawTime && typeof rawTime === 'object' && 'w' in rawTime){
  // célula XLSX com .w (texto formatado)
  timeStr = String(rawTime.w).trim();
} else if (typeof rawTime === 'string'){
  timeStr = rawTime.trim();
}

const rowOut = {
  Div:      r.Div,
  LigaName: ligaNome(r.Div),
  Date:     dtLabelFromRow(r),
  TS:       ts,
  Home:     r.HomeTeam,
  Away:     r.AwayTeam,
  TimeStr:  timeStr,
  Market:   pick.label,
  Code:     pick.code,
  Family:   pick.fam,
  Prob:     pick.prob,
  Odd:      pick.odd,
  EV:       pick.ev,
  Conf:     pick.conf,
  StakePct: stake,
  StakeEUR: stakeEUR,
  Explain:  explain(r.Div,r,pick,pack)
};


        if(!onlyHigh || rowOut.Conf!=='fraca') items.push(rowOut);
      }
      const one = pack.oneX2
        // Pool mais amplo para garantir que a aba 1X2 nunca fica vazia.
        // A seleção "forte" é feita em selectBest1x2 (prioriza SAFE + prob alta).
        .filter(o =>
          o.odd >= 1.20 &&
          o.prob >= 0.58
        )
        .map(o => ({
          Div: r.Div,
          LigaName: ligaNome(r.Div),
          Date: dtLabelFromRow(r),
          TS: ts,
          Home: r.HomeTeam,
          Away: r.AwayTeam,
          Pick: o.side,
          Prob: o.prob,
          Odd: o.odd,
          EV: o.ev,
          CLV: clvFor(r, o.side),
          IsSafe: SAFE_1X2_DIV.has(r.Div)
        }));
      oneX2List.push(...one);
    }

    // === Filtro por Ciclo (anti-jogos antigos) ===
    // Problema típico: alguns ficheiros de "new leagues" podem ficar desatualizados e trazer jogos antigos.
    // Solução: (1) por defeito, ignoramos jogos no passado; (2) opcionalmente filtramos por ciclo:
    //   - Sexta→Segunda (FMS)
    //   - Terça→Quinta (TTQ)
    // Nota: não altera o modelo/cálculo; apenas restringe o universo de jogos considerados.
    const FILTER_CYCLE = !!document.getElementById('forceToday')?.checked;

    const _nowRef = new Date();
    const _nowTs  = _nowRef.getTime();
    const PAST_GRACE_MS = 60*60*1000; // 1h de tolerância (jogos a decorrer)

    function startOfDay(dt){
      const d = new Date(dt);
      d.setHours(0,0,0,0);
      return d;
    }

    function cycleWindow(ref, cycle){
      const d = startOfDay(ref || Date.now());
      const day = d.getDay(); // 0=Dom ... 6=Sáb

      if(cycle === 'TTQ'){ // Terça (2) -> Sexta 00:00
        const backToTue = (day - 2 + 7) % 7;
        const start = new Date(d); start.setDate(start.getDate() - backToTue);
        const end = new Date(start); end.setDate(end.getDate() + 3); // Sexta 00:00
        return {start, end, label:'Terça a Quinta'};
      }

      // FMS: Sexta (5) -> Terça 00:00
      const backToFri = (day - 5 + 7) % 7;
      const start = new Date(d); start.setDate(start.getDate() - backToFri);
      const end = new Date(start); end.setDate(end.getDate() + 4); // Terça 00:00
      return {start, end, label:'Sexta a Segunda'};
    }

    function shiftWindow(w, days){
      const start = new Date(w.start); start.setDate(start.getDate() + days);
      const end   = new Date(w.end);   end.setDate(end.getDate() + days);
      return {start, end, label:w.label};
    }

    function nextWindowFromNow(cycle){
      const w0 = cycleWindow(_nowRef, cycle);
      // Se já passou, avançar 7 dias; se estamos dentro, manter; se ainda não começou (caso raro), manter.
      if(_nowTs >= w0.end.getTime()) return shiftWindow(w0, 7);
      return w0;
    }

    function _inRange(ts, a, b){
      const t = Number(ts||0);
      return t >= a.getTime() && t < b.getTime();
    }

    function filterUpcoming(list){
      return (list||[]).filter(it => it && it.TS && Number(it.TS) >= (_nowTs - PAST_GRACE_MS));
    }

    function applyCycleFilter(list){
      const upcoming = filterUpcoming(list);
      if(!FILTER_CYCLE) return {filtered: upcoming, windowLabel: ''};

      const wd = _nowRef.getDay();
      const prefCycle = (wd>=2 && wd<=4) ? 'TTQ' : 'FMS';
      const altCycle  = (prefCycle==='TTQ') ? 'FMS' : 'TTQ';

      const wPref = nextWindowFromNow(prefCycle);
      const wAlt  = nextWindowFromNow(altCycle);

      const pref = upcoming.filter(it => _inRange(it.TS, wPref.start, wPref.end));
      if(pref.length) return {filtered: pref, windowLabel: wPref.label};

      const alt = upcoming.filter(it => _inRange(it.TS, wAlt.start, wAlt.end));
      if(alt.length) return {filtered: alt, windowLabel: wAlt.label};

      // Se não houver jogos em nenhum ciclo (fixtures muito fracos/desatualizados),
      // devolvemos apenas "upcoming" para não ficar tudo vazio.
      return {filtered: upcoming, windowLabel: ''};
    }

    // Base pools (por omissão, tudo, mas SEM jogos antigos)
    let itemsBase = items;
    let oneX2Base = oneX2List;

    // aplicar sempre anti-passado; e aplicar ciclo se checkbox ativo
    const itRes  = applyCycleFilter(items);
    const oneRes = applyCycleFilter(oneX2List);

    if(itRes.filtered.length)  itemsBase = itRes.filtered;
    if(oneRes.filtered.length) oneX2Base = oneRes.filtered;

    // Mensagem informativa (opcional)
    if(FILTER_CYCLE && (itRes.windowLabel || oneRes.windowLabel)){
      try{ setMsg(`Filtro ativo: ${itRes.windowLabel || oneRes.windowLabel} (apenas jogos futuros)`); }catch(e){}
    }
itemsBase.sort((a,b)=> b.Prob - a.Prob);


    // Sem limites por liga/família ou nº máximo de picks:
    // usamos simplesmente todos os itens ordenados por data/hora.
    // Limitação a 10 picks, com distribuição fixa por tipo de mercado:
// 2 Over 1.5, 2 Cantos, 2 DNB, 2 DC (1X/X2) e 2 BTTS.
// Critério interno: maior probabilidade (EV não entra na escolha),
// com limiares por tipo de mercado que refletem a natureza de cada um.
// Ordenação baseia-se na probabilidade ajustada e usa o EV apenas como desempate suave.
// Assim continuamos a priorizar acerto, mas preferimos ligeiramente picks com valor positivo.
// ---- Núcleo de ordenação "inteligente" das potenciais picks ----
// Usamos um score composto: probabilidade é sempre o coração da decisão,
// mas damos pequenos ajustes por EV, CLV e perfil típico da liga.
function marketStyle(it){
  const lbl = String(it.Label || '').toLowerCase();
  const code = String(it.Code || '').toUpperCase();
  const fam  = String(it.Family || '').toUpperCase();

  // Cantos (match/team)
  if (lbl.includes('cantos') || code.startsWith('C_') || code.startsWith('HC_') || code.startsWith('AC_') || code.startsWith('CORN')) return 'CORNERS';
  // Cartões (removido)

  // BTTS
  if (code.startsWith('BTTS')) return 'BTTS';

  // Totais (golos)
  if (fam === 'TOTAL' || lbl.includes('golos') || lbl.includes('goals')){
    if (lbl.includes('over') || lbl.includes('+')) return 'OVER';
    if (lbl.includes('under') || lbl.includes('menos')) return 'UNDER';
    return 'TOTAL';
  }

  // Resultado / proteção
  if (fam === 'RESULTADO' || code.startsWith('DNB') || code.startsWith('DC') || code === '1' || code === 'X' || code === '2') return 'RESULTADO';

  // Asian Handicap
  if (fam === 'AH' || code.startsWith('AH')) return 'AH';

  return 'OUTRO';
}

function isTeamTotalUnder(it){
  const lbl = String(it.Label || '');
  const l = lbl.toLowerCase();
  if (!(l.includes(' under ') || l.includes(' under') || l.includes('menos'))) return false;
  const h = String(it.Home||'');
  const a = String(it.Away||'');
  const reH = new RegExp('^' + h.replace(/[.*+?^${}()|[\]\\]/g,'\\$&') + '\\s+under','i');
  const reA = new RegExp('^' + a.replace(/[.*+?^${}()|[\]\\]/g,'\\$&') + '\\s+under','i');
  // também aceita "EquipaX Menos de"
  const reHM = new RegExp('^' + h.replace(/[.*+?^${}()|[\]\\]/g,'\\$&') + '\\s+menos','i');
  const reAM = new RegExp('^' + a.replace(/[.*+?^${}()|[\]\\]/g,'\\$&') + '\\s+menos','i');
  return reH.test(lbl) || reA.test(lbl) || reHM.test(lbl) || reAM.test(lbl);
}
function isCornerMarket(it){
  const lbl = String(it.Label||'').toLowerCase();
  const code = String(it.Code||'').toUpperCase();
  return lbl.includes('cantos') || code.startsWith('C_') || code.startsWith('HC_') || code.startsWith('AC_') || code.startsWith('CORN');
}
function isCardMarket(it){
  const lbl = String(it.Label||'').toLowerCase();
  const code = String(it.Code||'').toUpperCase();
  return lbl.includes('cart') || code.startsWith('CARD') || code.startsWith('CRD');
}
function isMatchUnder35(it){
  const lbl = String(it.Label||'').toLowerCase();
  // "Under 3.5 golos" (do jogo) normalmente não começa por equipa
  return (lbl.includes('under 3.5') || lbl.includes('menos de 3.5')) && !isTeamTotalUnder(it);
}


function scoreItem(it){
  let s = it.Prob || 0;

  const odd = +it.Odd || +it.odd || 0;

  // 1) EV positivo (suave)
  if (typeof it.EV === 'number' && it.EV > 0){
    const evCap = Math.min(it.EV, 0.75);
    s += evCap * 0.10;
  }

  // 2) Preferência por odds "vendáveis" (evita 1.18-1.25 repetidamente)
  if (odd > 0){
    if (odd < 1.28) s -= 0.06;
    else if (odd < 1.35) s -= 0.02;
    else if (odd >= 1.38 && odd <= 2.05) s += 0.03;
    else if (odd >= 2.06 && odd <= 2.60) s += 0.015; // algum risco controlado
  }

  // 3) Evitar mercados "cagões": Under por equipa (principalmente 3.5)
  if (isTeamTotalUnder(it)) s -= 0.12;

  // 4) Under 3.5 do jogo ainda é válido, mas não pode dominar
  if (isMatchUnder35(it)) s -= 0.02;

  // 5) Bónus leve por variedade de mercado
  const estilo = marketStyle(it);
  if (estilo === 'CORNERS') s += 0.018;
  if (estilo === 'AH')      s += 0.010;

  // Ajuste por perfil estatístico de liga (OVER/UNDER/BTTS mais típicos)
  const regra = LIGA_REGRAS[it.Div];
  if (regra){
    if (regra.prefer && regra.prefer.includes('OVER')  && estilo === 'OVER')  s += 0.02;
    if (regra.prefer && regra.prefer.includes('BTTS')  && estilo === 'BTTS')  s += 0.02;
    if (regra.prefer && regra.prefer.includes('CORN')  && estilo === 'CORNERS') s += 0.02;

    if (regra.evitar && regra.evitar.includes('OVER')  && estilo === 'OVER')  s -= 0.015;
    if (regra.evitar && regra.evitar.includes('BTTS')  && estilo === 'BTTS')  s -= 0.015;
  }

  return s;
}

const scored = [...itemsBase].sort((a,b)=> scoreItem(b) - scoreItem(a));

// Controlo suave para não concentrar demasiadas picks no mesmo jogo
const matchCounts = {};
function matchKey(it){
  return `${it.Div}|${it.Date}|${it.Home}|${it.Away}`;
}
function canAddToMatch(it){
  const k = matchKey(it);
  const n = matchCounts[k] || 0;
  return n < 2; // no máximo 2 mercados por jogo
}
function registerMatch(it){
  const k = matchKey(it);
  matchCounts[k] = (matchCounts[k] || 0) + 1;
}

const chosen = [];
const counts = { totals:0, corners:0, cards:0, result:0, btts:0, ah:0 };
const MAX_PER_CAT = { totals:3, corners:3, cards:2, result:2, btts:2, ah:2, ht:1, special:1 }; // mix vendável (ajusta automaticamente se houver poucos jogos)

// limiares mínimos de probabilidade por tipo (em termos de prob já ajustada pAdj)
const THRESH = {
  totals:  0.64,   // golos (O/U do jogo) – equilibrado
  corners: 0.60,   // cantos tendem a ser mais voláteis
  cards:   0.58,   // cartões voláteis
  result:  0.70,   // DNB/DC mais conservador
  btts:    0.58,   // BTTS
  ah:      0.60,   // handicap/linhas
  ht:      0.58,   // intervalo (HT)
  special: 0.58    // especiais/combos (ex.: ambas as partes, 1X+O1.5)
};

// Helpers para saber se uma pick já foi escolhida
function alreadyChosen(it){
  return chosen.includes(it);
}

// Função genérica para escolher até 2 picks de um conjunto de códigos,
// tentando primeiro acima do limiar e, se não chegar a 2, completando abaixo do limiar.
function pickCategory(matchFn, key){
  const minProb = THRESH[key] ?? 0.0;
  const maxPicks = (MAX_PER_CAT && MAX_PER_CAT[key] != null) ? MAX_PER_CAT[key] : 2;

  // 1) Primeiro, picks fortes (>= limiar)
  for (const it of scored){
    if (counts[key] >= maxPicks) break;
    if (!matchFn(it)) continue;
    if (alreadyChosen(it)) continue;
    if (it.Prob < minProb) continue;
    if (!canAddToMatch(it)) continue;
    chosen.push(it);
    counts[key]++;
    registerMatch(it);
  }

  // 2) Se ainda não temos o mínimo, completar com as melhores restantes dessa categoria,
  // mesmo que fiquem abaixo do limiar (para garantir variedade).
  if (counts[key] < maxPicks){
    for (const it of scored){
      if (counts[key] >= maxPicks) break;
      if (!matchFn(it)) continue;
      if (alreadyChosen(it)) continue;
      if (!canAddToMatch(it)) continue;
      chosen.push(it);
      counts[key]++;
      registerMatch(it);
    }
  }
}


// 1) Totais (golos) — preferir mercados do jogo, evitar Under por equipa
pickCategory(it => {
  const st = marketStyle(it);
  if (!(st==='OVER' || st==='UNDER' || st==='TOTAL')) return false;
  if (isTeamTotalUnder(it)) return false;
  // evitar concentração em Under 3.5: aceita, mas não como filtro primário
  return true;
}, 'totals');

// 2) Cantos (match + equipa) — queremos isto sempre presente
pickCategory(it => isCornerMarket(it), 'corners');

// 3) Cartões (FT)
pickCategory(it => isCardMarket(it), 'cards');

// 4) Resultado (DNB/DC e afins)
pickCategory(it => {
  const code = String(it.Code||'').toUpperCase();
  return code.startsWith('DNB') || code.startsWith('DC') || String(it.Family||'').toUpperCase()==='RESULTADO';
}, 'result');

// 5) BTTS
pickCategory(it => String(it.Code||'').toUpperCase().startsWith('BTTS'), 'btts');

// 6) Handicap (AH)

// 7) Intervalo (HT) — aumentar elegibilidade para combos do intervalo (Over HT, HT/FT, 1X2 HT)
pickCategory(it => {
  const m = String(it.Market||'').toLowerCase();
  const code = String(it.Code||'').toUpperCase();
  return (
    m.includes('intervalo') || m.includes('1ª parte') || m.includes('1a parte') ||
    code.startsWith('HT_') || code.startsWith('HTFT_')
  );
}, 'ht');

// 8) Especiais/Combos — “Golo em ambas as partes” + combos populares (ex.: 1X+Over 1.5)
pickCategory(it => {
  const m = String(it.Market||'').toLowerCase();
  const code = String(it.Code||'').toUpperCase();
  if(code.startsWith('BH_') || m.includes('ambas as partes') || m.includes('ambas partes')) return true;
  if(code==='1X_O15' || code==='X2_O15') return true;
  // outros combos com '+' e referência a golos
  if(m.includes('+') && (m.includes('over') || m.includes('golo') || m.includes('golos'))) return true;
  return false;
}, 'special');

pickCategory(it => String(it.Family||'').toUpperCase()==='AH' || String(it.Code||'').toUpperCase().startsWith('AH'), 'ah');

// Fallback: se, por algum motivo, ainda tivermos menos de 10 picks
// (ex: poucas ligas/jogos activos), preenche com as próximas melhores por probabilidade,
// ainda respeitando o limite de mercados por jogo.
if (chosen.length < 10){
  for (const it of scored){
    if (chosen.length >= 10) break;
    if (alreadyChosen(it)) continue;
    if (!canAddToMatch(it)) continue;
    chosen.push(it);
    registerMatch(it);
  }
}

// Ordena as picks finais por data/hora para a tabela ficar legível
chosen.sort((a,b)=>a.TS-b.TS);
LAST_CHOSEN = chosen.slice();

// (Filtro por data desativado — mostra também jogos anteriores.)

    // Seleção melhorada de 1X2: só por probabilidade, forte e com limite por liga
    
function selectBest1x2(all){
      const MAX_PER_LEAGUE = 2;
      const MAX_PICKS_1X2 = 10;

      function score1x2(it){
        let s = it.Prob || 0;

        // Priorizar ligas SAFE (comportamento v9), mas sem bloquear a lista
        if (it.IsSafe) s += 0.02;

        if (typeof it.EV === 'number' && it.EV > 0){
          const evCap = Math.min(it.EV, 0.75);
          s += evCap * 0.15;
        }

        // Pequeno ajuste se a liga for tradicionalmente mais estável em resultado
        const regra = LIGA_REGRAS[it.Div];
        if (regra && regra.prefer && regra.prefer.includes('UNDER')){
          s += 0.01;
        }
        return s;
      }

      const ordered = [...(all||[])].sort((a,b)=> score1x2(b) - score1x2(a));
      const chosen1 = [];
      const perLiga = {};

      // Tiers: tenta forte -> médio -> fallback
      const tiers = [0.70, 0.66, 0.62, 0.58, 0.00];

      for (const minProb of tiers){
        for (const it of ordered){
          if (chosen1.length >= MAX_PICKS_1X2) break;
          if (chosen1.includes(it)) continue;
          if ((it.Prob||0) < minProb) continue;

          const lg = it.Div;
          perLiga[lg] = perLiga[lg] || 0;
          if (perLiga[lg] >= MAX_PER_LEAGUE) continue;

          chosen1.push(it);
          perLiga[lg]++;
        }
        if (chosen1.length) break; // já temos pelo menos 1 pick
      }

      // Se ainda assim estiver vazio (caso extremo), devolve o melhor absoluto
      if (!chosen1.length && ordered.length){
        chosen1.push(ordered[0]);
      }

      chosen1.sort((a,b)=>a.TS - b.TS);
      return chosen1;
    }


    LAST_1X2 = selectBest1x2(oneX2Base);

    // (Filtro por data desativado — mostra também jogos anteriores.)

    // Sumário (sem diagnóstico de calibração)
    const sum=document.getElementById('summary'); 
    if (sum){ 
      sum.style.display='block';
      sum.innerHTML=`<strong>${chosen.length}</strong> picks de ${usable.length} jogos.`;
    }

    // Garantir que o bloco de diagnóstico nunca fica visível
    const cdiv=document.getElementById('calib');
    if (cdiv){ cdiv.style.display='none'; cdiv.innerHTML=''; }

    // Tabela de picks


// Picks (cartões — mobile first, sem scroll horizontal, stats inline)
const picks = document.getElementById('picks');
picks.innerHTML = (chosen && chosen.length)
  ? chosen.map((x, i) => {
      const dTs = new Date(x.TS || Date.now());
      const pad = n => String(n).padStart(2,'0');
      const soData = `${pad(dTs.getDate())}/${pad(dTs.getMonth()+1)}/${dTs.getFullYear()}`;
      const soHora = `${pad(dTs.getHours())}:${pad(dTs.getMinutes())}`;

      const probPct = ((x.Prob||0)*100).toFixed(1)+'%';
      const oddVal = (x.OddDisp!=null ? x.OddDisp : x.Odd);
      const odd = (oddVal==null?'-':Number(oddVal).toFixed(2));
      const ev  = (x.EV==null?'-':(Number(x.EV)*100).toFixed(1)+'%');
      const confWidth = Math.min(100, Math.max(0,((x.Prob||0)-0.5)*200));

      // x.Explain já inclui mini-tabelas e classificação; será renderizado inline ao abrir
      const explainHTML = (x.Explain || '').trim() || '<div class="tiny">Sem detalhe disponível.</div>';

      return `
      <div class="match-card" data-match-idx="${i}">
        <div class="match-head" role="button" tabindex="0" aria-expanded="false">
          <div class="match-left">
            <div class="match-meta">
              <span>${x.LigaName||x.Div||''}</span>
              <span>•</span><span>${soData}</span>
              <span>•</span><span>${soHora}</span>
            </div>
            <div class="match-teams">${x.Home||''} <span style="opacity:.65;font-weight:800">vs</span> ${x.Away||''}</div>
            <div class="match-market">${x.Market||''}</div>
            <div class="prob-strip"><div class="fill" style="width:${((x.Prob||0)*100).toFixed(1)}%; background:${(x.Prob||0)>=0.75?'rgba(34,197,94,.95)':((x.Prob||0)>=0.65?'rgba(245,158,11,.95)':'rgba(239,68,68,.95)')};"></div></div>
          </div>
          <div class="match-right">
            <div class="match-kpis">
              <div class="kpi"><span>Prob.</span>${probPct}</div>
              <div class="kpi"><span>Odd</span>${odd}</div>
              <div class="kpi"><span>EV</span>${ev}</div>
              <div class="kpi"><span>Conf.</span>${x.Conf||''}</div>
            </div>
            <div class="tiny" style="text-align:right;opacity:.85">Tocar para ver estatísticas</div>
          </div>
        </div>

        <div class="match-body">
          
          <div class="explain">${explainHTML}</div>
        </div>
      </div>`;
    }).join('')
  : '<div class="tiny">Sem picks elegíveis neste conjunto.</div>';




    /* parlay-only: picksWrap hidden */

    // Múltipla (com odd mínima respeitada porque saiu de chosen, que já filtra por MIN_ODD nos mercados)
    const lowTarget = false;
    const rangeMin = 1.20;
    const rangeMax = 3.50;
    // Pool para múltipla: apenas picks de mercados (chosen) — 1X2 externo NÃO entra (pedido)
    const pool = [...chosen];

    // =====================
// Múltipla (persistente até ao dia seguinte ao jogo mais recente)
// - Caching em localStorage para manter a mesma múltipla entre dias
// - Expira à 00:00 do dia seguinte ao último jogo da múltipla
// - Algoritmo igual ao "LuxTips Igual V5 com multipla melhorada"
// =====================

function _parlayScore(x){
  const p = Math.max(0.0001, Math.min(0.9999, Number(x.Prob||0)));
  const ev = Number(x.EV||0);
  const odd = Math.max(1.0001, Number(x.Odd||1));
  return (p*120) + (ev*15) - ((odd-1)*4);
}

function buildBestParlay(items, maxLegs, maxTotalOdd){
  // Aplicar "haircut" à odd final para aproximar à realidade das casas quando usamos odds estimadas.
  // Interpretação pedida: no final retirar 15% à odd final (multiplica por 0.85).
  const PARLAY_HAIRCUT = 0.15;
  const HAIR = (1 - PARLAY_HAIRCUT);

  const MIN_PARLAY_ODD = 4.0;
  const MAX_PARLAY_ODD = 6.0;

  if (!items || !items.length) return [];

  const legs = Math.min(6, Math.max(2, Number(maxLegs || 6)));

  // Only consider eligible markets with reasonable odds
  const eligible = items.filter(it=>{
    const o = Number(it.Odd || it.odd || 1);
    return isFinite(o) && o >= 1.15;
  });

  // Avoid correlation: at most one pick per match
  const seenMatch = new Set();
  const pool = [];
  for(const it of eligible.sort((a,b)=>_parlayScore(b)-_parlayScore(a))){
    const key = (it.Home||'') + "|" + (it.Away||'');
    if(seenMatch.has(key)) continue;
    seenMatch.add(key);
    pool.push(it);
  }

  const finalPool = pool.length >= legs ? pool : eligible.slice(0,80);

  let best = [];
  let bestScore = -1e18;
  let bestOddRaw = 0;

  function dfs(i, picked, scoreSum, oddProdRaw){
    const oddAdj = oddProdRaw * HAIR;

    if (picked.length>=2 && oddAdj>=MIN_PARLAY_ODD && oddAdj<=MAX_PARLAY_ODD){
      if(scoreSum > bestScore){
        bestScore = scoreSum;
        best = picked.slice();
        bestOddRaw = oddProdRaw;
      }
    }
    if (i>=finalPool.length) return;
    if (picked.length>=legs) return;

    for(let j=i; j<finalPool.length; j++){
      const it = finalPool[j];
      const o = Number(it.Odd || it.odd || 1);
      const newRaw = oddProdRaw * o;

      // Respeitar o cap depois do haircut (cap efetivo)
      if(newRaw * HAIR > MAX_PARLAY_ODD + 1e-12) continue;

      picked.push(it);
      dfs(j+1, picked, scoreSum + _parlayScore(it), newRaw);
      picked.pop();
    }
  }

  dfs(0, [], 0, 1.0);

  // Guardar odd "ajustada" no objeto para UI (se existir)
  const finalAdj = (bestOddRaw>0 ? bestOddRaw*HAIR : 0);
  for(const it of best){
    it._ParlayOddAdj = finalAdj;
    it._ParlayHaircut = PARLAY_HAIRCUT;
  }

  best.sort((a,b)=>(b.Prob||0)-(a.Prob||0));
  return best.slice(0, legs);
}

function renderParlay(parlayArr, prod, targetParlay){
  const parDiv = document.getElementById('parlay');
  if(!parDiv) return;

  if(!(parlayArr && parlayArr.length>=2)){
    parDiv.innerHTML = `<div class="errorBox">Sem múltipla válida (mín. 4.00, máx. 6.00).</div>`;
    return;
  }

  // Ordenar por data/hora (usa TS quando existir)
  const arr = parlayArr.slice().sort((a,b)=>{
    const ta = (a.TS!=null && isFinite(a.TS)) ? Number(a.TS) : _safeParseTS(a);
    const tb = (b.TS!=null && isFinite(b.TS)) ? Number(b.TS) : _safeParseTS(b);
    return ta - tb;
  });

  const total = (prod && isFinite(prod)) ? Number(prod) : arr.reduce((acc,x)=>acc*(Number(x.Odd)||1),1);

  let body = `<div class="slipCard">`;

  // Render sequencial para manter ordenação por data/hora.
  // Mostra data/hora por baixo da liga (como pedido), não por baixo do jogo.
  let lastLeague = null;
  for(const x of arr){
    const liga = String(x.LigaName||x.Div||'');
    const home = String(x.Home||'');
    const away = String(x.Away||'');
    const market = String(x.Market||'');
    const dtLabel = _formatDTLabel(x);

    if(liga !== lastLeague){
      body += `<div class="slipLeague">${liga}</div><div class="slipLeagueDT">${dtLabel}</div>`;
      lastLeague = liga;
    }else{
      body += `<div class="slipLeagueSubDT">${dtLabel}</div>`;
    }

    body += `
      <div class="slipRow">
        <div class="slipTeams"><span class="teamChunk"><img class="teamLogo" data-team="${home}" data-div="${(x.Div||'')}" data-league="${liga}" alt="" referrerpolicy="no-referrer"> <span class="teamName">${home}</span></span> <span class="vs">vs</span> <span class="teamChunk"><img class="teamLogo" data-team="${away}" data-div="${(x.Div||'')}" data-league="${liga}" alt="" referrerpolicy="no-referrer"> <span class="teamName">${away}</span></span></div>
        <div class="pillPick">${market}</div>
      </div>
    `;
  }

  body += `<div class="slipOdd">Odd ${total.toFixed(2)}</div></div>
           <div class="slipNote">Odds e mercados podem variar por casa. Usa sempre gestão de banca.</div>`;
  parDiv.innerHTML = body;
  try{ hydrateTeamLogos(parDiv); }catch(e){}
}



// ---- Team Logos (A+) ----
// Fonte principal: TheSportsDB (searchteams). Pode falhar para nomes ambíguos; por isso há:
//  - normalização agressiva + aliases
//  - scoring com contexto (Div/League) para escolher o clube certo
//  - fallback visual (iniciais) quando não existe badge
const TEAM_LOGO_CACHE = new Map();

// Aliases: do nome que vem no Excel -> nome canónico (mais provável no TheSportsDB)
// ---- Aliases Consolidados (contém + exceções) ----
const TEAM_ALIAS = {

  // Inglaterra – abreviações frequentes no Excel
  "Man City":"Manchester City",
  "Man United":"Manchester United",
  "Man Utd":"Manchester United",
  "Nott'm Forest":"Nottingham Forest",
  "Nottm Forest":"Nottingham Forest",
  "Nott Forest":"Nottingham Forest",
  "Spurs":"Tottenham Hotspur",
  "Wolves":"Wolverhampton Wanderers",
  "West Ham":"West Ham United",
  "Brighton":"Brighton and Hove Albion",
  "Newcastle":"Newcastle United",
  "Leeds":"Leeds United",
  "Sheff United":"Sheffield United",
  "Sheff Utd":"Sheffield United",
  "Bristol City":"Bristol City FC",
  "AFC Wimbledon":"AFC Wimbledon",

  // Escócia – grafias simplificadas e aliases por país
  "Rangers":"Rangers FC",
  "Aberdeen":"Aberdeen FC",
  "Livingston":"Livingston FC",
  "St Mirren":"St. Mirren",
  "Airdrie":"Airdrieonians FC",
  "Airdrie Utd":"Airdrieonians FC",
  "Alloa":"Alloa Athletic FC",
  "Partick":"Partick Thistle FC",
  "Celtic":"Celtic FC",

  // Itália – nomes curtos muito ambíguos globalmente
  "Inter":"Inter Milan",
  "Milan":"AC Milan",
  "Roma":"AS Roma",
  "Verona":"Hellas Verona",
  "Lecce":"US Lecce",
  "Pisa":"Pisa Calcio",
  "Como":"Como 1907",
  "Napoli":"SSC Napoli",
  "Naples":"SSC Napoli",
  "Parma":"Parma Calcio 1913",
  "Torino":"Torino FC",
  "Fiorentina":"ACF Fiorentina",
  "Sassuolo":"US Sassuolo",
  "Lazio":"SS Lazio",
  "Bologna":"Bologna FC",
  "Bolonha":"Bologna FC",
  "Genoa":"Genoa CFC",
  "Cagliari":"Cagliari Calcio",
  "Salernitana":"US Salernitana",
  "Perugia":"AC Perugia Calcio",

  // Espanha – colisões por nomes genéricos
  "Alaves":"Deportivo Alavés",
  "Barcelona":"FC Barcelona",
  "Betis":"Real Betis",
  "Atleti":"Atlético Madrid",
  "Atletico":"Atlético Madrid",
  "Real":"Real Madrid CF",
  "Madrid":"Atlético Madrid",
  "Sevilla":"Sevilla FC",
  "Valencia":"Valencia CF",
  "Villarreal":"Villarreal CF",
  "Granada":"Granada CF",
  "Malaga":"Málaga CF",

  // Portugal – exceções locais
  "Benfica":"SL Benfica",
  "Porto":"FC Porto",
  "Sporting":"Sporting CP",
  "Vitoria":"Vitória Guimarães",
  "Vitoria SC":"Vitória Guimarães",
  "Braga":"SC Braga",
  "Boavista":"Boavista FC",
  "Guimaraes":"Vitória Guimarães",
  "Estoril":"GD Estoril Praia",

  // Alemanha – normalmente fáceis mas com reforço a siglas
  "Bayern":"FC Bayern München",
  "Dortmund":"Borussia Dortmund",
  "Leverkusen":"Bayer Leverkusen",
  "Leipzig":"RB Leipzig",
  "Gladbach":"Borussia Mönchengladbach",
  "Hamburg":"Hamburger SV",
  "FC Koln":"1. FC Köln",
  "Koln":"1. FC Köln",
  "Bremen":"Werder Bremen",

  // França – diferenças de denominação
  "PSG":"Paris Saint-Germain",
  "St Etienne":"AS Saint-Étienne",
  "Clermont":"Clermont Foot",
  "Guingamp":"EA Guingamp",
  "Grenoble":"Grenoble Foot 38",
  "Dunkerque":"USL Dunkerque",
  "Annecy":"FC Annecy",
  "Laval":"Stade Lavallois",

  // Bélgica
  "Anderlecht":"RSC Anderlecht",
  "Antwerp":"Royal Antwerp FC",
  "Brugge":"Club Brugge KV",

  // Holanda
  "Ajax":"AFC Ajax",
  "AZ":"AZ Alkmaar",
  "Alkmaar":"AZ Alkmaar",

  // Turquia – possíveis colisões por nomes simples
  "Alanyaspor":"Alanyaspor Kulübü",
  "Antalyaspor":"Antalyaspor Kulübü",
  "Andorra":"FC Andorra",

"A. Klagenfurt":"Austria Klagenfurt",
"A. Lustenau":"Austria Lustenau",
"U. Cluj":"Universitatea Cluj",
"Csikszereda M. Ciuc":"FK Csikszereda",
"M. Saransk":"Mordovia Saransk",
"R. Volgograd":"Rotor Volgograd",
"T. Moscow":"Torpedo Moscow",
"Volga N. Novgorod":"FC Volga Nizhny Novgorod",
"Yokohama F. Marinos":"Yokohama F Marinos",

"Bodo/Glimt":"Bodø/Glimt",
"Ull/Kisa":"Ullensaker/Kisa",
"Guangzhou R&F":"Guangzhou R and F F.C.",
"Sao Paulo":"São Paulo FC"

};


// Contexto por divisão (Football-Data.co.uk)
const DIV_CONTEXT = {
  "E0": { country:"England", leagueHints:["Premier League","English Premier League"] },
  "E1": { country:"England", leagueHints:["Championship"] },
  "E2": { country:"England", leagueHints:["League One"] },
  "E3": { country:"England", leagueHints:["League Two"] },
  "SC0":{ country:"Scotland", leagueHints:["Scottish Premiership"] },
  "SC1":{ country:"Scotland", leagueHints:["Championship"] },
  "I1": { country:"Italy", leagueHints:["Serie A","Italian Serie A"] },
  "I2": { country:"Italy", leagueHints:["Serie B"] },
  "D1": { country:"Germany", leagueHints:["Bundesliga"] },
  "D2": { country:"Germany", leagueHints:["2. Bundesliga"] },
  "SP1":{ country:"Spain", leagueHints:["La Liga","Spanish La Liga"] },
  "SP2":{ country:"Spain", leagueHints:["LaLiga2","Segunda"] },
  "F1": { country:"France", leagueHints:["Ligue 1"] },
  "F2": { country:"France", leagueHints:["Ligue 2"] },
  "P1": { country:"Portugal", leagueHints:["Primeira Liga","Liga Portugal"] },
  "N1": { country:"Netherlands", leagueHints:["Eredivisie"] },
  "B1": { country:"Belgium", leagueHints:["Jupiler Pro League","Belgian Pro League"] }
};

function _applyTeamAlias(raw){
  const s = String(raw||"").trim().replace(/\s+/g," ");
  if(!s) return s;
  if(TEAM_ALIAS[s]) return TEAM_ALIAS[s];

  // tentar sem pontuação comum
  const s2 = s.replace(/['’\.]/g,"").replace(/\s+/g," ").trim();
  if(TEAM_ALIAS[s2]) return TEAM_ALIAS[s2];

  // caso especial: Nott'm -> Nottm
  const s3 = s.replace(/Nott['’]m/i,"Nottm");
  if(TEAM_ALIAS[s3]) return TEAM_ALIAS[s3];

  return s;
}

function _normTeamName(name){
  let n = _applyTeamAlias(name);
  n = n.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  n = n.replace(/\./g," ").replace(/[’']/g,"");     // remove apóstrofos
  n = n.replace(/\s+/g," ").trim();

  // remover tokens comuns, mas manter palavras importantes (ex: United)
  n = n
    .replace(/\bFC\b/ig,"")
    .replace(/\bCF\b/ig,"")
    .replace(/\bAFC\b/ig,"")
    .replace(/\bAC\b/ig,"")
    .replace(/\bSC\b/ig,"")
    .replace(/\bCD\b/ig,"")
    .replace(/\bUD\b/ig,"")
    .replace(/\bAS\b/ig,"")
    .replace(/\bSS\b/ig,"")
    .replace(/\s+/g," ")
    .trim();

  return n;
}

function _normLoose(s){
  return String(s||"")
    .toLowerCase()
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .replace(/[’'\.]/g,"")
    .replace(/\s+/g," ")
    .trim();
}

function _getCtx(div, leagueLabel){
  const ctx = { country:"", leagueHints:[], leagueLabel: leagueLabel||"" };
  if(div && DIV_CONTEXT[div]){
    ctx.country = DIV_CONTEXT[div].country || "";
    ctx.leagueHints = Array.isArray(DIV_CONTEXT[div].leagueHints) ? DIV_CONTEXT[div].leagueHints.slice() : [];
  }
  if(leagueLabel) ctx.leagueHints.unshift(String(leagueLabel));
  return ctx;
}

function _scoreTeamCandidate(t, teamName, ctx){
  let s = 0;
  const sport = _normLoose(t.strSport||"");
  if(sport === "soccer") s += 80;
  const candName = _normLoose(t.strTeam||t.strAlternate||"");
  const qName = _normLoose(teamName||"");

  if(candName && qName){
    if(candName === qName) s += 70;
    else if(candName.startsWith(qName) || qName.startsWith(candName)) s += 35;
    else if(candName.includes(qName) || qName.includes(candName)) s += 25;
  }

  
  // --- Token overlap (ajuda nomes curtos tipo "Leeds" -> "Leeds United") ---
  const qTok = qName.split(" ").filter(Boolean);
  const cTok = candName.split(" ").filter(Boolean);

  if(qTok.length && cTok.length){
    // todos os tokens do query aparecem no candidato
    const allIn = qTok.every(tk => cTok.includes(tk));
    if(allIn) s += 55;

    // query é exatamente um token e existe como token no candidato
    if(qTok.length === 1 && cTok.includes(qTok[0]) && candName.length > qName.length) s += 35;

    // bónus por prefixo do candidato
    if(cTok[0] && qTok[0] && cTok[0] === qTok[0] && candName.length > qName.length) s += 18;
  }
const ctry = _normLoose(t.strCountry||"");
  if(ctx && ctx.country){
    const want = _normLoose(ctx.country);
    if(ctry === want) s += 25;
  }

  const lg = _normLoose(t.strLeague||"");
  if(ctx && Array.isArray(ctx.leagueHints) && ctx.leagueHints.length){
    for(const h of ctx.leagueHints){
      const hh = _normLoose(h);
      if(!hh) continue;
      if(lg === hh) { s += 18; break; }
      if(lg.includes(hh) || hh.includes(lg)) { s += 10; break; }
    }
  }

  // Preferir entradas com badge
  const badge = t.strTeamBadge || t.strBadge || t.strTeamLogo;
  if(badge && String(badge).startsWith("http")) s += 10;

  return s;
}

async function _fetchLogoSportsDB(teamName, ctx){
  const q = encodeURIComponent(teamName);
  const url = `https://www.thesportsdb.com/api/v1/json/3/searchteams.php?t=${q}`;
  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) return null;

  const js = await res.json().catch(()=>null);
  if(!js || !js.teams || !js.teams.length) return null;

  const context = _getCtx(ctx?.div, ctx?.league);

  let best = null;
  let bestScore = -1e9;
  for(const t of js.teams){
    const sc = _scoreTeamCandidate(t, teamName, context);
    if(sc > bestScore){
      bestScore = sc;
      best = t;
    }
  }

  const badge = best?.strTeamBadge || best?.strBadge || best?.strTeamLogo;
  return badge && String(badge).startsWith("http") ? badge : null;
}

function _makeInitials(teamRaw){
  const n = _normTeamName(teamRaw);
  if(!n) return "?";
  const parts = n.split(/\s+/).filter(Boolean);
  const a = (parts[0]||"")[0] || "";
  const b = (parts[1]||"")[0] || (parts[0]||"")[1] || "";
  const init = (a + b).toUpperCase();
  return init || "?";
}

async function getTeamLogoUrl(teamRaw, ctx){
  const key = _normTeamName(teamRaw);
  const cacheKey = `${key}||${ctx?.div||""}||${ctx?.league||""}`;
  if(!key) return null;
  if(TEAM_LOGO_CACHE.has(cacheKey)) return TEAM_LOGO_CACHE.get(cacheKey);

  // Tentativa 1: SportsDB com contexto (Div/Liga) — mais preciso quando funciona
  let url = null;
  try{ url = await _fetchLogoSportsDB(key, ctx||{}); }catch(e){ url = null; }

  // Tentativa 2: sem contexto (menos restritivo) — evita perder logos que antes apareciam
  if(!url){
    try{ url = await _fetchLogoSportsDB(key, {}); }catch(e){ url = null; }
  }

  // Tentativa 3: procurar com nome "raw" (mínima normalização, sem alias agressivo)
  if(!url){
    let raw = String(teamRaw||"").trim();
    raw = raw.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    raw = raw.replace(/\s+/g," ").trim();
    if(raw && raw.toLowerCase() !== key.toLowerCase()){
      try{ url = await _fetchLogoSportsDB(raw, ctx||{}); }catch(e){ url = null; }
      if(!url){
        try{ url = await _fetchLogoSportsDB(raw, {}); }catch(e){ url = null; }
      }
    }
  }

  TEAM_LOGO_CACHE.set(cacheKey, url);
  return url;
}

function hydrateTeamLogos(root){
  if(!root) return;
  const imgs = Array.from(root.querySelectorAll("img.teamLogo[data-team]"));
  imgs.forEach(img=>{
    const team = img.getAttribute("data-team") || "";
    const div = img.getAttribute("data-div") || "";
    const league = img.getAttribute("data-league") || "";

    // placeholder até carregar
    img.src = img.src || "data:image/gif;base64,R0lGODlhAQABAAAAACw=";

    getTeamLogoUrl(team, {div, league}).then(url=>{
      if(url){
        img.src = String(url||'').replace(/^http:\/\//,'https://');
      }else{
        // fallback: troca por "badge" com iniciais (mantém o espaço consistente)
        const span = document.createElement("span");
        span.className = "teamLogoFallback";
        span.textContent = _makeInitials(team);
        img.replaceWith(span);
      }
    }).catch(()=>{
      try{
        const span = document.createElement("span");
        span.className = "teamLogoFallback";
        span.textContent = _makeInitials(team);
        img.replaceWith(span);
      }catch(e){}
    });
  });
}
// ---- /Team Logos ----


// helpers locais do render (não dependem do motor)
function _safeParseTS(x){
  try{
    let d = String(x.Date||'').trim();
    let t = String(x.TimeStr||'').trim();

    // d pode vir como "dd/mm/yyyy" OU "dd/mm/yyyy hh:mm"
    if(/\d{1,2}:\d{2}/.test(d) && !t){
      const parts = d.split(/\s+/);
      d = parts[0] || d;
      t = parts[1] || '';
    }

    const m = d.match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
    if(!m) return 0;
    const day = parseInt(m[1],10);
    const mon = parseInt(m[2],10)-1;
    let year = parseInt(m[3],10);
    if(year < 100) year += 2000;

    let hh=0, mm=0;
    const mt = t.match(/(\d{1,2}):(\d{2})/);
    if(mt){
      hh = parseInt(mt[1],10);
      mm = parseInt(mt[2],10);
    }
    return new Date(year, mon, day, hh, mm, 0, 0).getTime();
  }catch(e){
    return 0;
  }
}

function _formatDTLabel(x){
  const dRaw = String(x.Date||'').trim();
  const tRaw = String(x.TimeStr||'').trim();

  // Se a data já inclui hora (ex.: "04/01/2026 19:45"), não repetir.
  if(/\d{1,2}:\d{2}/.test(dRaw)){
    // limpar duplicações tipo "19:45 : 19:45" se existirem
    return dRaw.replace(/\s*:\s*(\d{1,2}:\d{2})\s*$/, ' $1');
  }

  if(!tRaw) return dRaw;
  if(dRaw.includes(tRaw)) return dRaw;
  return `${dRaw} · ${tRaw}`;
}


const PARLAY_CACHE_KEY = 'luxtips_parlay_cache_v6';

// Cache da múltipla desativada (pedido do utilizador) — recalcula sempre.
let cachedUsed = false;


if (!cachedUsed){
  const elig = pool
    .filter(x => x.Odd>=rangeMin && x.Odd<=rangeMax && x.Prob>=0.58)
    .sort((a,b) => (b.EV*b.Prob)-(a.EV*a.Prob));

  const maxLegs = 6;
  const parlay = buildBestParlay(elig, maxLegs, targetParlay);

  let prod = 1;
  for (const x of parlay){ prod *= Number(x.Odd||1); }

  renderParlay(parlay, prod, targetParlay);

  // Grava cache para manter até ao dia seguinte ao último jogo da múltipla
  try{
    const expiresAt = computeParlayExpiry(parlay);
    if (parlay && parlay.length >= 2 && expiresAt){
      localStorage.setItem(PARLAY_CACHE_KEY, JSON.stringify({
        createdAt: Date.now(),
        expiresAt,
        prod,
        parlay
      }));
    }else{
      localStorage.removeItem(PARLAY_CACHE_KEY);
    }
  }catch(e){ /* ignore */ }
}


    // 1X2
    
// 1X2 (cartões — mobile first)
const b1=document.getElementById('best1x2');
b1.innerHTML = (LAST_1X2 && LAST_1X2.length)
  ? LAST_1X2.map(x=>{
      const prob=((x.Prob||0)*100).toFixed(1)+'%';
      const odd=(x.Odd==null?'-':Number(x.Odd).toFixed(2));
      const ev=(x.EV==null?'-':(Number(x.EV)*100).toFixed(1)+'%');
      const clv=(x.CLV==null?'-':(Number(x.CLV)*100).toFixed(1)+'%');
      return `<div class="match-card">
        <div class="match-head">
          <div class="match-left">
            <div class="match-meta"><span>${x.LigaName||x.Div||''}</span><span>•</span><span>${x.Date||''}</span></div>
            <div class="match-teams">${x.Home||''} <span style="opacity:.65;font-weight:800">vs</span> ${x.Away||''}</div>
            <div class="match-market"><strong>1X2</strong> — ${x.Pick||''}</div>
          </div>
          <div class="match-right">
            <div class="match-kpis">
              <div class="kpi"><span>Prob.</span>${prob}</div>
              <div class="kpi"><span>Odd</span>${odd}</div>
              <div class="kpi"><span>EV</span>${ev}</div>
              <div class="kpi"><span>CLV</span>${clv}</div>
            </div>
          </div>
        </div>
      </div>`;
    }).join('')
  : '<div class="tiny">Sem 1X2 elegíveis neste conjunto.</div>';
document.getElementById('best1x2Wrap').style.display='block';

    // Guardar resultados em cache (4h), apenas para os mesmos fixtures
    try{
      let parlayLegs = null, parlayProd = null;
      const rawPar = localStorage.getItem(PARLAY_CACHE_KEY);
      if (rawPar){
        const pc = JSON.parse(rawPar);
        if (pc && pc.expiresAt && Date.now() < Number(pc.expiresAt) && Array.isArray(pc.parlay) && pc.parlay.length>=2){
          parlayLegs = pc.parlay;
          parlayProd = pc.prod;
        }
      }
      saveResultsCache(fxSig, {
        LAST_CHOSEN,
        LAST_1X2,
        summaryHTML: (sum && sum.innerHTML) ? sum.innerHTML : '',
        picksHTML: (picks && picks.innerHTML) ? picks.innerHTML : '',
        best1x2HTML: (b1 && b1.innerHTML) ? b1.innerHTML : '',
        parlayHTML: (document.getElementById('parlay') && document.getElementById('parlay').innerHTML) ? document.getElementById('parlay').innerHTML : '',
        parlay: parlayLegs,
        parlayProd: parlayProd,
        parlayTarget: targetParlay
      });
    }catch(e){ /* ignore */ }



    document.getElementById('warn').style.display='none';

    // Mostrar tabs de navegação após gerar resultados
    const tabs = document.getElementById('resultsTabs');
    if (tabs){
      tabs.style.display = 'flex';
      const first = tabs.querySelector('.tab-btn[data-target="picksWrap"]') || tabs.querySelector('.tab-btn');
      if (first) first.classList.add('tab-active');
    }
  }catch(err){
    console.error(err);
    const w=document.getElementById('warn');
    w.textContent='Erro: '+(err.message||err);
    w.style.display='block';
  } finally {
    finishLoading();
  }
});


// ==== UI helpers: botões flutuantes (Topo / Fechar) ====
let __closeAllBtn = null;
function updateCloseAllVisibility(){
  if(!__closeAllBtn) return;
  const anyOpen = !!document.querySelector('.match-card.open');
  __closeAllBtn.style.display = anyOpen ? 'block' : 'none';
}

document.addEventListener('DOMContentLoaded', ()=>{
  // Botão "Fechar" (fecha todas as explicações abertas)
  __closeAllBtn = document.getElementById('closeAll');
  if (__closeAllBtn){
    __closeAllBtn.addEventListener('click', ()=>{
      document.querySelectorAll('.match-card.open').forEach(c=>{
        c.classList.remove('open');
        const h = c.querySelector('.match-head');
        if (h) h.setAttribute('aria-expanded','false');
      });
      updateCloseAllVisibility();
    });
  }
  updateCloseAllVisibility();
});

// ==== UX: abrir/fechar estatísticas inline + botão topo ====
(function(){
  // Toggle do cartão (click + teclado)
  document.addEventListener('click', (ev)=>{
    const closeBtn = ev.target.closest('[data-action="closeMatch"]');
    if (closeBtn){
      const card = closeBtn.closest('.match-card');
      if (card){
        card.classList.remove('open');
        const head = card.querySelector('.match-head');
        if (head) head.setAttribute('aria-expanded','false');
      }
      updateCloseAllVisibility();
      ev.stopPropagation();
      return;
    }

    const head = ev.target.closest('.match-head');
    if (!head) return;
    const card = head.closest('.match-card');
    if (!card) return;

    const isOpen = card.classList.toggle('open');
    head.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    if (!isOpen){
      const body = card.querySelector('.match-body');
      if (body) body.querySelectorAll('.mini-stats-panel').forEach(p=>p.remove());
    }
      updateCloseAllVisibility();
  });

  document.addEventListener('keydown', (ev)=>{
    if (ev.key !== 'Enter' && ev.key !== ' ') return;
    const head = ev.target.closest && ev.target.closest('.match-head');
    if (!head) return;
    ev.preventDefault();
    head.click();
  });
})();


// ==== Export CSV (picks e 1X2) ====
function toCSV(arr, headers){
  const esc=v=>(v===undefined||v===null)?'':String(v).split('"').join('""');
  const lines = arr.map(o=>headers.map(h=>`"${esc(o[h])}"`).join(','));
  return [headers.join(','), ...lines].join('\n');
}

// Navegação das tabs de resultados (fixas no topo)
const resultsTabsEl = document.getElementById('resultsTabs');
if (resultsTabsEl){
  resultsTabsEl.addEventListener('click', (ev)=>{
    const btn = ev.target.closest('.tab-btn');
    if (!btn) return;
    const targetId = btn.getAttribute('data-target');
    if (targetId){
      const card = document.getElementById(targetId);
      if (card){
        card.scrollIntoView({behavior:'smooth', block:'start'});
      }
    }
    btn.classList.add('tab-active');
  });
}

// copiar texto para clipboard (fallback incluído)
function copyToClipboard(text){
  if(navigator.clipboard && navigator.clipboard.writeText){
    return navigator.clipboard.writeText(text);
  }
  const ta=document.createElement('textarea');
  ta.value=text;
  ta.style.position='fixed';
  ta.style.left='-9999px';
  document.body.appendChild(ta);
  ta.select();
  try{ document.execCommand('copy'); }
  finally{ document.body.removeChild(ta); }
}

const _expAll=document.getElementById('expAll'); if(_expAll) _expAll.addEventListener('click',()=>{
  if(!LAST_CHOSEN.length){ alert('Gera picks primeiro.'); return; }
  const headers=['Liga','Data','Home','Away','Mercado','Prob','Odd','EV','Stake%','StakeEUR','Conf','Explicacao'];
  const rows=LAST_CHOSEN.map(x=>({
    'Liga':x.LigaName,'Data':x.Date,'Home':x.Home,'Away':x.Away,'Mercado':x.Market,
    'Prob':(x.Prob*100).toFixed(1)+'%','Odd':x.Odd.toFixed(2),'EV':(x.EV*100).toFixed(1)+'%',
    'Stake%':(x.StakePct*100).toFixed(2)+'%','StakeEUR':('€'+x.StakeEUR.toFixed(2)),'Conf':x.Conf,'Explicacao':x.Explain
  }));
  const blob=new Blob([toCSV(rows, headers)],{type:'text/csv'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='LuxTIPS_picks.csv'; a.click();
});
const _exp1x2=document.getElementById('exp1x2'); if(_exp1x2) _exp1x2.addEventListener('click',()=>{
  if(!LAST_1X2.length){ alert('Gera picks primeiro.'); return; }
  const headers=['Liga','Data','Home','Away','Pick','Prob','Odd','EV','CLV'];
  const rows=LAST_1X2.map(x=>({
    'Liga':x.LigaName,'Data':x.Date,'Home':x.Home,'Away':x.Away,'Pick':x.Pick,
    'Prob':(x.Prob*100).toFixed(1)+'%','Odd':x.Odd.toFixed(2),'EV':(x.EV*100).toFixed(1)+'%',
    'CLV':(x.CLV==null?'-':(x.CLV*100).toFixed(1)+'%')
  }));
  const blob=new Blob([toCSV(rows, headers)],{type:'text/csv'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='LuxTIPS_1X2.csv'; a.click();
});

// botão "Copiar p/ Excel" (tudo junto, ordenado por data)
const _copyExcel=document.getElementById('copyExcel'); if(_copyExcel) _copyExcel.addEventListener('click', async ()=>{
  if (!LAST_1X2.length && !LAST_CHOSEN.length) {
    alert('Gera picks primeiro.');
    return;
  }

  // Cabeçalho igual ao teu Excel
  const lines = [];
  lines.push(['Liga','Data','Home','Away','Pick','Prob','Odd'].join('\t'));

  // Junta 1X2 + Picks num array comum
  const merged = [];

  // 1X2 -> Pick = 1 / X / 2
  LAST_1X2.forEach(x => {
    merged.push({
      TS:  x.TS || 0,
      Liga: x.LigaName,
      Data: x.Date,
      Home: x.Home,
      Away: x.Away,
      Pick: x.Pick,
      Prob: (x.Prob * 100).toFixed(1) + '%',
      Odd:  x.Odd.toFixed(2)
    });
  });

  // Picks (DNB, DC, etc.) -> Pick = nome do mercado
  LAST_CHOSEN.forEach(x => {
    merged.push({
      TS:  x.TS || 0,
      Liga: x.LigaName,
      Data: x.Date,
      Home: x.Home,
      Away: x.Away,
      Pick: x.Market,  // ex.: "Dupla Chance 1X", "DNB Casa"
      Prob: (x.Prob * 100).toFixed(1) + '%',
      Odd:  x.Odd.toFixed(2)
    });
  });

  // Ordenar por data/hora (TS crescente)
  merged.sort((a, b) => a.TS - b.TS);

  // Montar linhas em TSV
  merged.forEach(r => {
    lines.push([
      r.Liga,
      r.Data,
      r.Home,
      r.Away,
      r.Pick,
      r.Prob,
      r.Odd
    ].join('\t'));
  });

  const txt = lines.join('\n');

  try {
    await copyToClipboard(txt);
    alert('Copiado para a área de transferência.\nAgora é só colar no Excel.');
  } catch (e) {
    console.error(e);
    alert('Não foi possível copiar automaticamente. Tenta de novo ou verifica permissões do browser.');
  }
});

</script>
<script>
// === Auto-download — v6 (Europa + novas ligas) ===
(function(){
  const FX_ID='fixturesFile', HS_ID='historyFiles', WARN_ID='warn';

  // Fixtures europeus + fixtures das novas ligas
  const FIXTURES_URLS = [
    'https://www.football-data.co.uk/fixtures.xlsx',
    'https://www.football-data.co.uk/new_league_fixtures.xlsx'
  ];

  // Histórico europeu + histórico das novas ligas (todas as épocas num só ficheiro)
  const HISTORY_URLS=[
    'https://www.football-data.co.uk/mmz4281/2526/all-euro-data-2025-2026.xlsx',
    'https://www.football-data.co.uk/mmz4281/2425/all-euro-data-2024-2025.xlsx',
    'https://www.football-data.co.uk/mmz4281/2324/all-euro-data-2023-2024.xlsx',
    'https://www.football-data.co.uk/mmz4281/2223/all-euro-data-2022-2023.xlsx',
    'https://www.football-data.co.uk/mmz4281/2122/all-euro-data-2021-2022.xlsx',
    'https://www.football-data.co.uk/mmz4281/2021/all-euro-data-2020-2021.xlsx',
    'https://www.football-data.co.uk/new/new_leagues_data.xlsx'
  ];

  function $(id){return document.getElementById(id)}
  function setMsg(t){ const w=$(WARN_ID); if(w){ w.style.display='block'; w.textContent=t; } }
  function log(){ try{ console.log('[LuxTIPS auto]', ...arguments); }catch(e){} }

  async function tryFetchAB(url){
    try{
      const r=await fetch(url,{mode:'cors',credentials:'omit'});
      if(r.ok){ return await r.arrayBuffer(); }
      log('status', r.status, url);
    }catch(e){ log('err', e && e.message, url); }
    return null;
  }

  async function fetchAsXLSX(url){
    const workerUrl = `${CF_WORKER}?key=${encodeURIComponent(PROXY_KEY)}&url=${encodeURIComponent(url)}`;
    const tries = [
      workerUrl,
      url,
      `https://cors.isomorphic-git.org/${url}`,
      `https://corsproxy.io/?${encodeURIComponent(url)}`,
      `https://api.allorigins.workers.dev/raw?url=${encodeURIComponent(url)}`,
      `https://thingproxy.freeboard.io/fetch/${url}`
    ];

    for(const t of tries){
      const ab = await tryFetchAB(t);
      if(ab){
        log('ok via', t);
        return new Blob([ab], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
      }
    }
    throw new Error('All fetch attempts failed for '+url);
  }

  async function autoDownload(){
    const fx=$(FX_ID), hs=$(HS_ID);
    if(!fx||!hs){ log('inputs not found'); return; }
    if((fx.files&&fx.files.length)||(hs.files&&hs.files.length)){ log('already have files'); return; }

    // Durante o carregamento automático bloqueamos o botão "Gerar Picks"
    if (typeof runBtn !== 'undefined' && runBtn){
      runBtn.disabled = true;
      runBtn.classList.add('btn-disabled');
    }

    try{
      startLoading('A carregar dados....');
      setMsg('A obter fixtures e histórico automaticamente…');

      // Fixtures (Europa + novas ligas)
      const dtFx = new DataTransfer();
      let fxOk = 0, fxFail = 0;
      for (const url of FIXTURES_URLS){
        try{
          const b = await fetchAsXLSX(url);
          const name = url.split('/').pop() || 'fixtures.xlsx';
          dtFx.items.add(new File(
            [b],
            name,
            { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }
          ));
          fxOk++;
          setMsg(`A obter fixtures… (${fxOk} ok / ${fxFail} falhados)`);
        }catch(e){
          fxFail++;
          log('fixtures fail', url, e && e.message);
          setMsg(`A obter fixtures… (${fxOk} ok / ${fxFail} falhados)`);
        }
      }
      if (fxOk > 0){
        fx.files = dtFx.files;
        fx.dispatchEvent(new Event('change'));
      }

      // Histórico (Europa + novas ligas)
      const dtHs = new DataTransfer(); 
      let ok = 0, fail = 0;
      for (const url of HISTORY_URLS){
        try{
          const b = await fetchAsXLSX(url);
          const name = url.split('/').pop() || 'history.xlsx';
          dtHs.items.add(new File(
            [b],
            name,
            { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }
          ));
          ok++;
          setMsg(`A obter histórico… (${ok} ok / ${fail} falhados)`);
        }catch(e){
          fail++;
          log('history fail', url, e && e.message);
          setMsg(`A obter histórico… (${ok} ok / ${fail} falhados)`);
        }
      }
      if (ok > 0){
        hs.files = dtHs.files;
        hs.dispatchEvent(new Event('change'));
      }
      setMsg(`Fixtures e histórico carregados (fixtures: ${fxOk} ok / ${fxFail} falhados · histórico: ${ok} ficheiros, ignorados: ${fail}).`);
    }catch(e){
      log('fatal', e && e.message);
      setMsg('Falha ao obter dados automaticamente. Pode carregar os ficheiros manualmente.');
    } finally {
            // Não escondemos a intro aqui: mantém-se até terminar a geração.
      // (evita que a intro desapareça antes dos prognósticos aparecerem)
if (typeof runBtn !== 'undefined' && runBtn){
        runBtn.disabled = false;
        runBtn.classList.remove('btn-disabled');
      // Auto-gerar picks assim que os ficheiros estiverem no input
      try{ if (fx && fx.files && fx.files.length && hs && hs.files && hs.files.length){ setTimeout(()=>{ try{ runBtn.click(); }catch(e){} }, 450); } }catch(e){}
      }
    }
  }
  // === MODO MANUAL ===
  // Não executar downloads automáticos. O utilizador carrega os ficheiros no formulário.
  function manualInit(){
    try{
      const fx=$(FX_ID), hs=$(HS_ID);
      const fileCard = document.getElementById('fileCard');
      if(fileCard) fileCard.style.display='block';
      if (typeof runBtn !== 'undefined' && runBtn){
        runBtn.disabled = false;
        runBtn.classList.remove('btn-disabled');
      }
      setMsg('Carregue os ficheiros manualmente (Fixtures e Histórico) e depois clique em "Gerar prognósticos".');
    }catch(e){}
  }

  if(document.readyState==='complete'||document.readyState==='interactive') { try{ const fc=document.getElementById('fileCard'); if(fc) fc.style.display='none'; }catch(e){} try{ autoDownload(); }catch(e){ console.error(e);} }
  else document.addEventListener('DOMContentLoaded', ()=> { try{ const fc=document.getElementById('fileCard'); if(fc) fc.style.display='none'; }catch(e){} try{ autoDownload(); }catch(e){ console.error(e);} });
})();
</script>
<script>
// === Auto-download — v6 (Europa + novas ligas) ===
(function(){
  const FX_ID='fixturesFile', HS_ID='historyFiles', WARN_ID='warn';

  // Fixtures europeus + fixtures das novas ligas
  const FIXTURES_URLS = [
    'https://www.football-data.co.uk/fixtures.xlsx',
    'https://www.football-data.co.uk/new_league_fixtures.xlsx'
  ];

  // Histórico europeu + histórico das novas ligas (todas as épocas num só ficheiro)
  const HISTORY_URLS=[
    'https://www.football-data.co.uk/mmz4281/2526/all-euro-data-2025-2026.xlsx',
    'https://www.football-data.co.uk/mmz4281/2425/all-euro-data-2024-2025.xlsx',
    'https://www.football-data.co.uk/mmz4281/2324/all-euro-data-2023-2024.xlsx',
    'https://www.football-data.co.uk/mmz4281/2223/all-euro-data-2022-2023.xlsx',
    'https://www.football-data.co.uk/mmz4281/2122/all-euro-data-2021-2022.xlsx',
    'https://www.football-data.co.uk/mmz4281/2021/all-euro-data-2020-2021.xlsx',
    'https://www.football-data.co.uk/new/new_leagues_data.xlsx'
  ];

  function $(id){return document.getElementById(id)}
  function setMsg(t){ const w=$(WARN_ID); if(w){ w.style.display='block'; w.textContent=t; } }
  function log(){ try{ console.log('[LuxTIPS auto]', ...arguments); }catch(e){} }

  async function tryFetchAB(url){
    try{
      const r=await fetch(url,{mode:'cors',credentials:'omit'});
      if(r.ok){ return await r.arrayBuffer(); }
      log('status', r.status, url);
    }catch(e){ log('err', e && e.message, url); }
    return null;
  }

  async function fetchAsXLSX(url){
    const workerUrl = `${CF_WORKER}?key=${encodeURIComponent(PROXY_KEY)}&url=${encodeURIComponent(url)}`;
    const tries = [
      workerUrl,
      url,
      `https://cors.isomorphic-git.org/${url}`,
      `https://corsproxy.io/?${encodeURIComponent(url)}`,
      `https://api.allorigins.workers.dev/raw?url=${encodeURIComponent(url)}`,
      `https://thingproxy.freeboard.io/fetch/${url}`
    ];

    for(const t of tries){
      const ab = await tryFetchAB(t);
      if(ab){
        log('ok via', t);
        return new Blob([ab], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
      }
    }
    throw new Error('All fetch attempts failed for '+url);
  }

  async function autoDownload(){
    const fx=$(FX_ID), hs=$(HS_ID);
    if(!fx||!hs){ log('inputs not found'); return; }
    if((fx.files&&fx.files.length)||(hs.files&&hs.files.length)){ log('already have files'); return; }

    // Durante o carregamento automático bloqueamos o botão "Gerar Picks"
    if (typeof runBtn !== 'undefined' && runBtn){
      runBtn.disabled = true;
      runBtn.classList.add('btn-disabled');
    }

    try{
      startLoading('A carregar dados....');
      setMsg('A obter fixtures e histórico automaticamente…');

      // Fixtures (Europa + novas ligas)
      const dtFx = new DataTransfer();
      let fxOk = 0, fxFail = 0;
      for (const url of FIXTURES_URLS){
        try{
          const b = await fetchAsXLSX(url);
          const name = url.split('/').pop() || 'fixtures.xlsx';
          dtFx.items.add(new File(
            [b],
            name,
            { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }
          ));
          fxOk++;
          setMsg(`A obter fixtures… (${fxOk} ok / ${fxFail} falhados)`);
        }catch(e){
          fxFail++;
          log('fixtures fail', url, e && e.message);
          setMsg(`A obter fixtures… (${fxOk} ok / ${fxFail} falhados)`);
        }
      }
      if (fxOk > 0){
        fx.files = dtFx.files;
        fx.dispatchEvent(new Event('change'));
      }

      // Histórico (Europa + novas ligas)
      const dtHs = new DataTransfer(); 
      let ok = 0, fail = 0;
      for (const url of HISTORY_URLS){
        try{
          const b = await fetchAsXLSX(url);
          const name = url.split('/').pop() || 'history.xlsx';
          dtHs.items.add(new File(
            [b],
            name,
            { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }
          ));
          ok++;
          setMsg(`A obter histórico… (${ok} ok / ${fail} falhados)`);
        }catch(e){
          fail++;
          log('history fail', url, e && e.message);
          setMsg(`A obter histórico… (${ok} ok / ${fail} falhados)`);
        }
      }
      if (ok > 0){
        hs.files = dtHs.files;
        hs.dispatchEvent(new Event('change'));
      }
      setMsg(`Fixtures e histórico carregados (fixtures: ${fxOk} ok / ${fxFail} falhados · histórico: ${ok} ficheiros, ignorados: ${fail}).`);
    }catch(e){
      log('fatal', e && e.message);
      setMsg('Falha ao obter dados automaticamente. Pode carregar os ficheiros manualmente.');
    } finally {
            // Não escondemos a intro aqui: mantém-se até terminar a geração.
      // (evita que a intro desapareça antes dos prognósticos aparecerem)
if (typeof runBtn !== 'undefined' && runBtn){
        runBtn.disabled = false;
        runBtn.classList.remove('btn-disabled');
      // Auto-gerar picks assim que os ficheiros estiverem no input
      try{ if (fx && fx.files && fx.files.length && hs && hs.files && hs.files.length){ setTimeout(()=>{ try{ runBtn.click(); }catch(e){} }, 450); } }catch(e){}
      }
    }
  }
  // === MODO MANUAL ===
  // Não executar downloads automáticos. O utilizador carrega os ficheiros no formulário.
  function manualInit(){
    try{
      const fx=$(FX_ID), hs=$(HS_ID);
      const fileCard = document.getElementById('fileCard');
      if(fileCard) fileCard.style.display='block';
      if (typeof runBtn !== 'undefined' && runBtn){
        runBtn.disabled = false;
        runBtn.classList.remove('btn-disabled');
      }
      setMsg('Carregue os ficheiros manualmente (Fixtures e Histórico) e depois clique em "Gerar prognósticos".');
    }catch(e){}
  }

  if(document.readyState==='complete'||document.readyState==='interactive') { try{ const fc=document.getElementById('fileCard'); if(fc) fc.style.display='none'; }catch(e){} try{ autoDownload(); }catch(e){ console.error(e);} }
  else document.addEventListener('DOMContentLoaded', ()=> { try{ const fc=document.getElementById('fileCard'); if(fc) fc.style.display='none'; }catch(e){} try{ autoDownload(); }catch(e){ console.error(e);} });
})();
</script>
<script>

<script>
// ================= INTRO (logo + progresso) =================
// A intro deve durar exatamente o tempo de carregamento.
// Sincroniza a visibilidade do #introOverlay com o #loadingOverlay.
(function(){
  const intro = document.getElementById('introOverlay');
  const loading = document.getElementById('loadingOverlay');
  if(!intro) return;

  const show = () => {
    intro.style.display = 'flex';
    intro.classList.remove('intro-out');
  };
  const hide = () => {
    // saída suave
    intro.classList.add('intro-out');
    window.setTimeout(()=>{
      intro.style.display = 'none';
      intro.classList.remove('intro-out');
    }, 520);
  };

  const isVisible = (el) => {
    if(!el) return false;
    const cs = window.getComputedStyle(el);
    return cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0';
  };

  // Estado inicial: se estiver a carregar (auto-run), mantém; caso contrário, esconde.
  window.requestAnimationFrame(()=>{
    if(isVisible(loading)) show();
    else hide();
  });

  // Observa alterações no loading overlay e sincroniza.
  if(loading){
    const sync = ()=>{
      if(isVisible(loading)) show();
      else hide();
    };
    const mo = new MutationObserver(sync);
    mo.observe(loading, { attributes:true, attributeFilter:['style','class'] });

    // fallback: alguns fluxos atualizam progress sem mexer em style, por isso também sincronizamos no próximo tick
    window.addEventListener('luxtips:loading:on', show);
    window.addEventListener('luxtips:loading:off', hide);
  }
})();
</script>
<button aria-label="Fechar explicações" class="fab fab-close" id="closeAll" style="display:none">Fechar</button>
<script>
document.addEventListener('DOMContentLoaded', () => {
  try {
    const fc = document.getElementById('fileCard');
    if (fc) fc.style.display = 'none';
  } catch (e) {}
  try { autoDownload(); } catch (e) { console.warn('[LuxTIPS auto] autoDownload failed', e); }
});
</script>
<script>
// ===== LuxTIPS Parlay-Only Overrides (variedade + slip UI) =====
(function(){
  // Normaliza uma "família" para controlar repetição (sem bloquear mercados)
  function marketGroup(x){
    const m = String(x.Market||'').toLowerCase();
    if(m.includes('canto')) return 'CORNERS';
    if(m.includes('btts') || m.includes('ambas marcam')) return 'BTTS';
    if(m.includes('ah')) return 'AH';
    if(m.includes('dnb')) return 'DNB';
    if(m.includes('dupla chance') || m.trim()==='1x' || m.trim()==='x2' || m.trim()==='12') return 'DC';
    if(m.includes('intervalo') || m.startsWith('ht') || m.includes('1ª parte') || m.includes('1a parte')) return 'HT';
    if(m.includes('ambas as partes') || m.includes('ambas partes')) return 'BOTH_HALVES';
    if(m.includes('+') && (m.includes('golo') || m.includes('golos') || m.includes('over'))) return 'COMBO';
    if(m.includes('over') || m.includes('under') || m.includes('golo') || m.includes('golos')) return 'TOTAL';
    if(m==='1' || m==='x' || m==='2' || m.includes('win')) return 'RESULT';
    return 'OTHER';
  }

  // Substitui o builder para impor variedade
  const _origScore = (typeof _parlayScore === 'function') ? _parlayScore : (x=> (x.Prob||0));
  window.buildBestParlay = function(items, maxLegs, maxTotalOdd){
    const MIN_PARLAY_ODD = 4.0;
    const MAX_PARLAY_ODD = 6.0;
    if (!items || !items.length) return [];
    const capOdd = Math.min(MAX_PARLAY_ODD, Math.max(1.01, Number(maxTotalOdd||MAX_PARLAY_ODD)));
    const logCap = Math.log(capOdd);

    // candidatos top N por score base
    const cand = items.slice()
      .sort((a,b)=>_origScore(b)-_origScore(a))
      .slice(0, 60) // mais pool para permitir variedade
      .map(x=>({
        x,
        group: marketGroup(x),
        logOdd: Math.log(Math.max(1.0001, Number(x.Odd||1))),
        score: _origScore(x)
      }))
      .sort((a,b)=> b.score - a.score);

    let best=[], bestScore=-1e18;

    function dfs(i, picked, scoreSum, logSum, groupCount){
      if(picked.length>=2 && logSum >= Math.log(MIN_PARLAY_ODD)){
        if(scoreSum>bestScore){ bestScore=scoreSum; best=picked.slice(); }
      }
      if(i>=cand.length) return;
      if(picked.length>=maxLegs) return;

      // pruning otimista
      let optimistic=scoreSum;
      for(let k=i;k<Math.min(cand.length, i+(maxLegs-picked.length));k++){
        optimistic += cand[k].score;
      }
      if(optimistic<=bestScore) return;

      for(let j=i;j<cand.length;j++){
        const c=cand[j];
        const newLog = logSum + c.logOdd;
        if(newLog > logCap + 1e-9) continue;

        // variedade: penalização e limites suaves
        const g = c.group;
        const cnt = groupCount[g]||0;

        // limites: corners no máx 1; outras famílias no máx 2
        if(g==='CORNERS' && cnt>=1) continue;
        if(cnt>=2) continue;

        // não repetir o mesmo jogo
        const key = `${c.x.Date||''}::${c.x.Home||''}::${c.x.Away||''}`;
        if(picked.some(p=>`${p.Date||''}::${p.Home||''}::${p.Away||''}`===key)) continue;

        // penalização por repetição para incentivar variedade (sem bloquear)
        const penalty = (cnt>0 ? (g==='CORNERS'? 1.2 : 0.55*cnt) : 0);
        picked.push(c.x);
        groupCount[g]=(cnt+1);
        dfs(j+1, picked, scoreSum + (c.score - penalty), newLog, groupCount);
        groupCount[g]=cnt;
        picked.pop();
      }
    }

    dfs(0, [], 0, 0, {});
    // apresentação: ordenar por data/hora
    best.sort((a,b)=> (a.TS||0)-(b.TS||0));
    return best.slice(0, maxLegs);
  };
})();

</script>
<script>
(function(){
  function showToast(msg){
    let t = document.querySelector('.toast');
    if(!t){
      t = document.createElement('div');
      t.className = 'toast';
      document.body.appendChild(t);
    }
    t.textContent = msg || 'OK';
    t.classList.add('show');
    window.clearTimeout(t._tm);
    t._tm = window.setTimeout(()=>t.classList.remove('show'), 1600);
  }

  function getSlipText(){
    const par = document.getElementById('parlay');
    if(!par) return '';
    // Normaliza espaços e remove linhas vazias duplicadas
    const raw = (par.innerText || '').replace(/\s+\n/g,'\n').trim();
    return raw;
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      showToast('Copiado');
      return true;
    }catch(e){
      // fallback
      try{
        const ta = document.createElement('textarea');
        ta.value = txt;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.focus(); ta.select();
        document.execCommand('copy');
        ta.remove();
        showToast('Copiado');
        return true;
      }catch(e2){
        showToast('Não foi possível copiar');
        return false;
      }
    }
  }

  function wire(){
if(btnTop) btnTop.addEventListener('click', ()=>window.scrollTo({top:0,behavior:'smooth'}));

    // Mostrar footer quando já existir slip renderizado
    const par = document.getElementById('parlay');
    const footer = document.getElementById('parlayFooter');
    if(par && footer){
      const obs = new MutationObserver(()=>{
        const hasSlip = !!par.querySelector('.slipCard') || !!par.innerText.trim();
        footer.style.display = hasSlip ? 'flex' : 'none';
      });
      obs.observe(par, {childList:true, subtree:true});
    }
  }

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', wire);
  else wire();
})();
</script>
</body>
</html>
